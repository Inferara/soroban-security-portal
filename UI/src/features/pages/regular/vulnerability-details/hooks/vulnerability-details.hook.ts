import { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { 
  getVulnerabilityByIdCall,
  getProtocolByIdCall,
  getReportByIdCall,
  getAuditorByIdCall,
  getCompanyByIdCall
} from '../../../../../api/soroban-security-portal/soroban-security-portal-api';
import { Vulnerability } from '../../../../../api/soroban-security-portal/models/vulnerability';
import { ProtocolItem } from '../../../../../api/soroban-security-portal/models/protocol';
import { Report } from '../../../../../api/soroban-security-portal/models/report';
import { AuditorItem } from '../../../../../api/soroban-security-portal/models/auditor';
import { CompanyItem } from '../../../../../api/soroban-security-portal/models/company';

export const useVulnerabilityDetails = () => {
  const { id } = useParams<{ id: string }>();
  const vulnerabilityId = parseInt(id ?? '0');
  
  const [vulnerability, setVulnerability] = useState<Vulnerability | null>(null);
  const [protocol, setProtocol] = useState<ProtocolItem | null>(null);
  const [report, setReport] = useState<Report | null>(null);
  const [auditor, setAuditor] = useState<AuditorItem | null>(null);
  const [company, setCompany] = useState<CompanyItem | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchVulnerabilityDetails = async () => {
    try {
      setLoading(true);
      setError(null);

      if (!vulnerabilityId) {
        setError('Invalid vulnerability ID');
        return;
      }

      // Fetch vulnerability details
      const vulnerabilityData = await getVulnerabilityByIdCall(vulnerabilityId);
      setVulnerability(vulnerabilityData);

      // Fetch related entities in parallel
      const promises = [];
      
      if (vulnerabilityData.protocolId) {
        promises.push(getProtocolByIdCall(vulnerabilityData.protocolId));
      } else {
        promises.push(Promise.resolve(null));
      }
      
      if (vulnerabilityData.reportId) {
        promises.push(getReportByIdCall(vulnerabilityData.reportId));
      } else {
        promises.push(Promise.resolve(null));
      }
      
      if (vulnerabilityData.auditorId) {
        promises.push(getAuditorByIdCall(vulnerabilityData.auditorId));
      } else {
        promises.push(Promise.resolve(null));
      }

      if (vulnerabilityData.companyId) {
        promises.push(getCompanyByIdCall(vulnerabilityData.companyId));
      } else {
        promises.push(Promise.resolve(null));
      }

      const [protocolData, reportData, auditorData, companyData] = await Promise.all(promises);
      
      setProtocol(protocolData as ProtocolItem | null);
      setReport(reportData as Report | null);
      setAuditor(auditorData as AuditorItem | null);
      setCompany(companyData as CompanyItem | null);

    } catch (err) {
      console.error('Error fetching vulnerability details:', err);
      setError('Failed to load vulnerability details');
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    if (vulnerabilityId) {
      void fetchVulnerabilityDetails();
    }
  }, [vulnerabilityId]);

  return {
    vulnerability,
    protocol,
    report,
    auditor,
    company,
    loading,
    error,
    vulnerabilityId
  };
};