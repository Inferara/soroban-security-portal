import { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import {
  getVulnerabilityByIdCall,
  getProtocolByIdCall,
  getReportByIdCall,
  getAuditorByIdCall,
  getCompanyByIdCall,
  getThreadDataCall,
  addReplyCall,
  watchThreadCall
} from '../../../../../api/soroban-security-portal/soroban-security-portal-api';
import { Vulnerability } from '../../../../../api/soroban-security-portal/models/vulnerability';
import { Thread } from '../../../../../api/soroban-security-portal/models/thread';
import { ProtocolItem } from '../../../../../api/soroban-security-portal/models/protocol';
import { Report } from '../../../../../api/soroban-security-portal/models/report';
import { AuditorItem } from '../../../../../api/soroban-security-portal/models/auditor';
import { CompanyItem } from '../../../../../api/soroban-security-portal/models/company';

export const useVulnerabilityDetails = () => {
  const { id } = useParams<{ id: string }>();
  const vulnerabilityId = parseInt(id ?? '0');

  const [vulnerability, setVulnerability] = useState<Vulnerability | null>(null);
  const [protocol, setProtocol] = useState<ProtocolItem | null>(null);
  const [report, setReport] = useState<Report | null>(null);
  const [auditor, setAuditor] = useState<AuditorItem | null>(null);
  const [company, setCompany] = useState<CompanyItem | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [thread, setThread] = useState<Thread | null>(null);
  const [threadLoading, setThreadLoading] = useState(false);

  const fetchVulnerabilityDetails = async () => {
    try {
      setLoading(true);
      setError(null);

      if (!vulnerabilityId) {
        setError('Invalid vulnerability ID');
        return;
      }

      // Fetch vulnerability details
      const vulnerabilityData = await getVulnerabilityByIdCall(vulnerabilityId);
      setVulnerability(vulnerabilityData);

      // Fetch related entities in parallel
      const promises = [];

      if (vulnerabilityData.protocolId) {
        promises.push(getProtocolByIdCall(vulnerabilityData.protocolId));
      } else {
        promises.push(Promise.resolve(null));
      }

      if (vulnerabilityData.reportId) {
        promises.push(getReportByIdCall(vulnerabilityData.reportId));
      } else {
        promises.push(Promise.resolve(null));
      }

      if (vulnerabilityData.auditorId) {
        promises.push(getAuditorByIdCall(vulnerabilityData.auditorId));
      } else {
        promises.push(Promise.resolve(null));
      }

      if (vulnerabilityData.companyId) {
        promises.push(getCompanyByIdCall(vulnerabilityData.companyId));
      } else {
        promises.push(Promise.resolve(null));
      }

      const [protocolData, reportData, auditorData, companyData] = await Promise.all(promises);

      setProtocol(protocolData as ProtocolItem | null);
      setReport(reportData as Report | null);
      setAuditor(auditorData as AuditorItem | null);
      setCompany(companyData as CompanyItem | null);

    } catch (err) {
      console.error('Error fetching vulnerability details:', err);
      setError('Failed to load vulnerability details');
    } finally {
      setLoading(false);
    }
  };

  const fetchThread = async () => {
    if (!vulnerabilityId) return;
    try {
      setThreadLoading(true);
      const threadData = await getThreadDataCall(vulnerabilityId);
      setThread(threadData);
    } catch (err) {
      console.error('Error fetching thread:', err);
    } finally {
      setThreadLoading(false);
    }
  };

  const addReply = async (content: string) => {
    if (!thread || !content.trim()) return;
    try {
      await addReplyCall(thread.id, content);
      await fetchThread(); // Refresh thread
    } catch (err) {
      console.error('Error adding reply:', err);
      throw err;
    }
  };

  const toggleWatch = async () => {
    if (!thread) return;
    try {
      await watchThreadCall(thread.id, !thread.isUserWatching);
      setThread(prev => prev ? { ...prev, isUserWatching: !prev.isUserWatching } : null);
    } catch (err) {
      console.error('Error toggling watch:', err);
    }
  };

  useEffect(() => {
    if (vulnerabilityId) {
      void fetchVulnerabilityDetails();
      void fetchThread();
    }
  }, [vulnerabilityId]);

  return {
    vulnerability,
    protocol,
    report,
    auditor,
    company,
    loading,
    error,
    vulnerabilityId,
    thread,
    threadLoading,
    addReply,
    toggleWatch,
    refreshThread: fetchThread
  };
};