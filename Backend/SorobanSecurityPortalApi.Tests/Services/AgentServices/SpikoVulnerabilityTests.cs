using System.Text.Json;
using Microsoft.Extensions.Logging;
using Pgvector;
using SorobanSecurityPortalApi.Common;
using SorobanSecurityPortalApi.Data.Processors;
using SorobanSecurityPortalApi.Models.DbModels;
using SorobanSecurityPortalApi.Models.ViewModels;
using SorobanSecurityPortalApi.Services.AgentServices;
using SorobanSecurityPortalApi.Services.AgentServices.Types;

namespace SorobanSecurityPortalApi.Tests.Services.AgentServices;

/// <summary>
/// Tests for extracting vulnerabilities from the Spiko Stellar Contracts audit report.
/// Report ID: 66
/// Auditor: Halborn
/// Protocol: Spiko
///
/// This test suite verifies that the 5 vulnerabilities from the Spiko Stellar Contracts
/// audit can be properly extracted and created in the system following the contribution guidelines.
///
/// Vulnerabilities:
/// - HAL-01: Incorrect Token Burn Source in Redemption Execution - High - Fixed
/// - HAL-02: Unrecoverable Admin Role Removal - High - Fixed
/// - HAL-03: Idempotency Keys Consumed on No-Op Operations - Medium - Fixed
/// - HAL-04: Fixed Initialization Logic in Separate Function - Medium - Fixed
/// - HAL-05: Inadequate In-Code Documentation - Low - Fixed
///
/// Issue: https://github.com/SorobanSecurity/soroban-security-portal/issues/108
/// Report: https://www.halborn.com/audits/spiko/stellar-contracts-879885
/// Portal: https://sorobansecurity.com/report/66
/// </summary>
public class SpikoVulnerabilityTests
{
    private readonly Mock<IGeminiAgentService> _agentServiceMock;
    private readonly Mock<IReportProcessor> _reportProcessorMock;
    private readonly Mock<IVulnerabilityProcessor> _vulnerabilityProcessorMock;
    private readonly Mock<ICategoryProcessor> _categoryProcessorMock;
    private readonly Mock<IGeminiEmbeddingService> _embeddingServiceMock;
    private readonly Mock<IUserContextAccessor> _userContextAccessorMock;
    private readonly Mock<ILogger<VulnerabilityExtractionService>> _loggerMock;

    // Spiko Stellar Contracts Report ID
    private const int SpikoReportId = 66;

    public SpikoVulnerabilityTests()
    {
        _agentServiceMock = new Mock<IGeminiAgentService>();
        _reportProcessorMock = new Mock<IReportProcessor>();
        _vulnerabilityProcessorMock = new Mock<IVulnerabilityProcessor>();
        _categoryProcessorMock = new Mock<ICategoryProcessor>();
        _embeddingServiceMock = new Mock<IGeminiEmbeddingService>();
        _userContextAccessorMock = new Mock<IUserContextAccessor>();
        _loggerMock = new Mock<ILogger<VulnerabilityExtractionService>>();
    }

    #region Spiko Test Data

    /// <summary>
    /// Returns the expected vulnerabilities from the Spiko Stellar Contracts audit report.
    /// These match the findings from the Halborn audit.
    /// </summary>
    private static List<ClassifiedVulnerability> GetSpikoExpectedVulnerabilities()
    {
        return new List<ClassifiedVulnerability>
        {
            new()
            {
                SectionId = "1",
                Title = "Incorrect Token Burn Source in Redemption Execution",
                Description = @"During redemption execution, the contract attempts to burn tokens from the user's account instead of from the Redemption contract's balance where tokens were escrowed during the initial redeem call. This causes execution to revert due to insufficient user balance, leaving redemptions stuck in ""Pending"" status with funds locked in the contract.

## **Metadata**

**File(s)**
`contracts/redemption/src/contract.rs`

**Location(s)**
`execute_redemptions()` (line 166)

## **Recommendation**

Correct the redemption execution logic so that token burns are performed from the Redemption contract balance rather than from the user account to prevent pending redemptions and locked escrowed funds.

## **Status**

Fixed",
                Impact = "Redemptions stuck in Pending status with funds locked in the contract.",
                Recommendation = "Correct the redemption execution logic so that token burns are performed from the Redemption contract balance rather than from the user account.",
                Location = "contracts/redemption/src/contract.rs:execute_redemptions()",
                Severity = VulnerabilitySeverity.High,
                Tags = new List<string> { "Logic Bug", "Token Operations" },
                Category = (int)VulnerabilityCategory.Valid
            },
            new()
            {
                SectionId = "2",
                Title = "Unrecoverable Admin Role Removal",
                Description = @"The contract exports AccessControl's default `renounce_admin` entrypoint, allowing authenticated admins to permanently remove the Admin key from storage. While not directly compromising funds, this creates operational risk by preventing future role administration without a recovery mechanism.

## **Metadata**

**File(s)**
AccessControl crate

**Location(s)**
`renounce_admin()`

## **Recommendation**

Prevent the admin role from being renounced without an alternative recovery mechanism by overriding or replacing the default `renounce_admin` flow with an explicit rotation/proposal-accept process.

## **Status**

Fixed",
                Impact = "Permanent loss of administrative control over the contract with no recovery mechanism.",
                Recommendation = "Prevent the admin role from being renounced without an alternative recovery mechanism by overriding or replacing the default renounce_admin flow.",
                Location = "AccessControl crate:renounce_admin()",
                Severity = VulnerabilitySeverity.High,
                Tags = new List<string> { "Access Control", "Configuration" },
                Category = (int)VulnerabilityCategory.Valid
            },
            new()
            {
                SectionId = "3",
                Title = "Idempotency Keys Consumed on No-Op Operations",
                Description = @"Batch operations and individual transfers consume idempotency keys and emit events even when no state change occurs (empty batches or zero amounts). This degrades UX, wastes storage slots, and may break client-side retry logic.

## **Metadata**

**File(s)**
`contracts/token/src/contract.rs`

**Location(s)**
`mint_batch()`
`burn_batch()`
`safe_transfer()`
`transfer()`
`mint()`
`burn()`

## **Recommendation**

Ensure idempotency keys and events are only consumed/emitted when an operation produces a real state change (reject empty-batch and zero-amount operations).

## **Status**

Fixed",
                Impact = "Degraded UX, wasted storage slots, and broken client-side retry logic.",
                Recommendation = "Ensure idempotency keys and events are only consumed/emitted when an operation produces a real state change.",
                Location = "contracts/token/src/contract.rs:mint_batch(), burn_batch(), safe_transfer(), transfer(), mint(), burn()",
                Severity = VulnerabilitySeverity.Medium,
                Tags = new List<string> { "Gas Optimization", "Input Validation" },
                Category = (int)VulnerabilityCategory.Valid
            },
            new()
            {
                SectionId = "4",
                Title = "Fixed Initialization Logic in Separate Function",
                Description = @"The `initialize()` function in PermissionManager only sets a fixed role relationship without dynamic inputs. Separating this from the constructor adds deployment sequencing risk without functional benefit.

## **Metadata**

**File(s)**
`contracts/permission-manager/src/contract.rs`

**Location(s)**
`initialize()`

## **Recommendation**

Move fixed, non-parameterized initialization logic into the constructor to eliminate unnecessary public initialization entrypoints and reduce deployment sequencing risk.

## **Status**

Fixed",
                Impact = "Deployment sequencing risk without functional benefit.",
                Recommendation = "Move fixed, non-parameterized initialization logic into the constructor to eliminate unnecessary public initialization entrypoints.",
                Location = "contracts/permission-manager/src/contract.rs:initialize()",
                Severity = VulnerabilitySeverity.Medium,
                Tags = new List<string> { "Best Practices", "Configuration" },
                Category = (int)VulnerabilityCategory.Valid
            },
            new()
            {
                SectionId = "5",
                Title = "Inadequate In-Code Documentation",
                Description = @"Insufficient inline documentation throughout the contracts increases misconfiguration risk and reduces auditability for future reviewers and operators.

## **Metadata**

**File(s)**
Multiple contracts

## **Recommendation**

Improve in-code documentation to reduce misconfiguration and improve auditability.

## **Status**

Fixed",
                Impact = "Increased misconfiguration risk and reduced auditability.",
                Recommendation = "Improve in-code documentation to reduce misconfiguration and improve auditability.",
                Location = "Multiple contracts",
                Severity = VulnerabilitySeverity.Low,
                Tags = new List<string> { "Documentation", "Best Practices" },
                Category = (int)VulnerabilityCategory.Valid
            }
        };
    }

    /// <summary>
    /// Sample markdown content representing the Spiko Stellar Contracts audit report.
    /// </summary>
    private static string GetSpikoReportMarkdown()
    {
        return @"# Spiko Stellar Contracts Security Audit Report

## Executive Summary

Halborn conducted a comprehensive security assessment of Spiko's Stellar Contracts,
examining the Soroban smart contracts for token redemption and permission management.
The review identified 5 total issues: 2 high-severity vulnerabilities, 2 medium-severity
issues, and 1 low-severity/informational finding.

**Auditor:** Halborn
**Protocol:** Spiko
**Published:** October 3, 2025

## Findings

### HAL-01: Incorrect Token Burn Source in Redemption Execution

**Severity:** High

**Description:**
During redemption execution, the contract attempts to burn tokens from the user's account
instead of from the Redemption contract's balance where tokens were escrowed during the
initial redeem call. This causes execution to revert due to insufficient user balance,
leaving redemptions stuck in ""Pending"" status with funds locked in the contract.

**File(s):** `contracts/redemption/src/contract.rs`
**Location(s):** `execute_redemptions()` (line 166)

**Recommendation:**
Correct the redemption execution logic so that token burns are performed from the
Redemption contract balance rather than from the user account to prevent pending
redemptions and locked escrowed funds.

**Status:** Fixed

### HAL-02: Unrecoverable Admin Role Removal

**Severity:** High

**Description:**
The contract exports AccessControl's default `renounce_admin` entrypoint, allowing
authenticated admins to permanently remove the Admin key from storage. While not
directly compromising funds, this creates operational risk by preventing future role
administration without a recovery mechanism.

**File(s):** AccessControl crate
**Location(s):** `renounce_admin()`

**Recommendation:**
Prevent the admin role from being renounced without an alternative recovery mechanism
by overriding or replacing the default `renounce_admin` flow with an explicit
rotation/proposal-accept process.

**Status:** Fixed

### HAL-03: Idempotency Keys Consumed on No-Op Operations

**Severity:** Medium

**Description:**
Batch operations and individual transfers consume idempotency keys and emit events
even when no state change occurs (empty batches or zero amounts). This degrades UX,
wastes storage slots, and may break client-side retry logic.

**File(s):** `contracts/token/src/contract.rs`
**Location(s):** `mint_batch()`, `burn_batch()`, `safe_transfer()`, `transfer()`, `mint()`, `burn()`

**Recommendation:**
Ensure idempotency keys and events are only consumed/emitted when an operation
produces a real state change (reject empty-batch and zero-amount operations).

**Status:** Fixed

### HAL-04: Fixed Initialization Logic in Separate Function

**Severity:** Medium

**Description:**
The `initialize()` function in PermissionManager only sets a fixed role relationship
without dynamic inputs. Separating this from the constructor adds deployment
sequencing risk without functional benefit.

**File(s):** `contracts/permission-manager/src/contract.rs`
**Location(s):** `initialize()`

**Recommendation:**
Move fixed, non-parameterized initialization logic into the constructor to eliminate
unnecessary public initialization entrypoints and reduce deployment sequencing risk.

**Status:** Fixed

### HAL-05: Inadequate In-Code Documentation

**Severity:** Low/Informational

**Description:**
Insufficient inline documentation throughout the contracts increases misconfiguration
risk and reduces auditability for future reviewers and operators.

**File(s):** Multiple contracts

**Recommendation:**
Improve in-code documentation to reduce misconfiguration and improve auditability.

**Status:** Fixed

## Overall Assessment

All identified issues were completely addressed by the Spiko team per the audit conclusion.
";
    }

    #endregion

    #region Extraction Tests

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_ExtractsAllFiveVulnerabilities()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Ok>();
        var ok = (Result<VulnerabilityExtractionResultViewModel, string>.Ok)result;
        ok.Value.TotalExtracted.Should().Be(5, "Spiko audit report contains exactly 5 vulnerabilities");
        ok.Value.TotalCreated.Should().Be(5);
        ok.Value.DuplicatesSkipped.Should().Be(0);
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_CorrectlySetsHighSeverityVulnerabilities()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var createdVulnerabilities = new List<VulnerabilityModel>();
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .Callback<VulnerabilityModel>(v => createdVulnerabilities.Add(v))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = createdVulnerabilities.Count; return v; });

        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert
        var highSeverityVulns = createdVulnerabilities.Where(v => v.Severity == VulnerabilitySeverity.High).ToList();
        highSeverityVulns.Should().HaveCount(2, "HAL-01 and HAL-02 are high severity");
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_CorrectlySetsMediumSeverityVulnerabilities()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var createdVulnerabilities = new List<VulnerabilityModel>();
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .Callback<VulnerabilityModel>(v => createdVulnerabilities.Add(v))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = createdVulnerabilities.Count; return v; });

        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert
        var mediumSeverityVulns = createdVulnerabilities.Where(v => v.Severity == VulnerabilitySeverity.Medium).ToList();
        mediumSeverityVulns.Should().HaveCount(2, "HAL-03 and HAL-04 are medium severity");
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_CorrectlySetsLowSeverityVulnerabilities()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var createdVulnerabilities = new List<VulnerabilityModel>();
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .Callback<VulnerabilityModel>(v => createdVulnerabilities.Add(v))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = createdVulnerabilities.Count; return v; });

        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert
        var lowSeverityVulns = createdVulnerabilities.Where(v => v.Severity == VulnerabilitySeverity.Low).ToList();
        lowSeverityVulns.Should().HaveCount(1, "HAL-05 is low/informational severity");
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_AssignsCorrectReportId()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var createdVulnerabilities = new List<VulnerabilityModel>();
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .Callback<VulnerabilityModel>(v => createdVulnerabilities.Add(v))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = createdVulnerabilities.Count; return v; });

        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert
        createdVulnerabilities.Should().AllSatisfy(v => v.ReportId.Should().Be(SpikoReportId));
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_AssignsValidCategory()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var createdVulnerabilities = new List<VulnerabilityModel>();
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .Callback<VulnerabilityModel>(v => createdVulnerabilities.Add(v))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = createdVulnerabilities.Count; return v; });

        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert
        // All Spiko vulnerabilities were fixed, so they should be marked as Valid
        createdVulnerabilities.Should().AllSatisfy(v =>
            v.Category.Should().Be(VulnerabilityCategory.Valid,
                "All Spiko vulnerabilities were fixed and should be marked as Valid"));
    }

    #endregion

    #region Title Validation Tests

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_ExtractsCorrectVulnerabilityTitles()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var createdVulnerabilities = new List<VulnerabilityModel>();
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .Callback<VulnerabilityModel>(v => createdVulnerabilities.Add(v))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = createdVulnerabilities.Count; return v; });

        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert - Verify vulnerability titles follow contribution guidelines (no ID prefixes like "HAL-01:")
        var titles = createdVulnerabilities.Select(v => v.Title).ToList();

        titles.Should().Contain(t => t.Contains("Token Burn Source") || t.Contains("Redemption Execution"));
        titles.Should().Contain(t => t.Contains("Admin Role") || t.Contains("Unrecoverable"));
        titles.Should().Contain(t => t.Contains("Idempotency") || t.Contains("No-Op"));
        titles.Should().Contain(t => t.Contains("Initialization") || t.Contains("Separate Function"));
        titles.Should().Contain(t => t.Contains("Documentation"));

        // Per contribution guidelines: titles should NOT contain numerical labels like [A-03] or HAL-XX
        titles.Should().NotContain(t => t.StartsWith("HAL-"));
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_TitlesDoNotContainIdPrefixes()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var createdVulnerabilities = new List<VulnerabilityModel>();
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .Callback<VulnerabilityModel>(v => createdVulnerabilities.Add(v))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = createdVulnerabilities.Count; return v; });

        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert
        foreach (var vuln in createdVulnerabilities)
        {
            vuln.Title.Should().NotMatchRegex(@"^HAL-\d{2}:",
                "Titles should not start with Halborn-style vulnerability IDs per contribution guidelines");
            vuln.Title.Should().NotMatchRegex(@"^\[\w+-\d+\]",
                "Titles should not start with bracket-style IDs like [A-03]");
            vuln.Title.Should().NotMatchRegex(@"^\d+\.\d+",
                "Titles should not start with version-style numbering like 4.1.12");
        }
    }

    #endregion

    #region Description Format Tests

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_DescriptionsContainMetadataSection()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var createdVulnerabilities = new List<VulnerabilityModel>();
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .Callback<VulnerabilityModel>(v => createdVulnerabilities.Add(v))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = createdVulnerabilities.Count; return v; });

        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert - Per contribution guidelines, descriptions should include metadata
        foreach (var vuln in createdVulnerabilities)
        {
            vuln.Description.Should().NotBeNullOrWhiteSpace("Description should contain vulnerability details");
            // Verify metadata section with File(s) information
            vuln.Description.Should().Contain("File(s)", "Description should contain File(s) metadata");
        }
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_DescriptionsContainRecommendationSection()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var createdVulnerabilities = new List<VulnerabilityModel>();
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .Callback<VulnerabilityModel>(v => createdVulnerabilities.Add(v))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = createdVulnerabilities.Count; return v; });

        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert - Per contribution guidelines, descriptions should include Recommendation section
        foreach (var vuln in createdVulnerabilities)
        {
            vuln.Description.Should().Contain("Recommendation",
                "Description should contain Recommendation section per contribution guidelines");
        }
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_DescriptionsContainStatusSection()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var createdVulnerabilities = new List<VulnerabilityModel>();
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .Callback<VulnerabilityModel>(v => createdVulnerabilities.Add(v))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = createdVulnerabilities.Count; return v; });

        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert - Per contribution guidelines, descriptions should include Status section
        foreach (var vuln in createdVulnerabilities)
        {
            vuln.Description.Should().Contain("Status",
                "Description should contain Status section per contribution guidelines");
        }
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_DescriptionsUseLevel2Headings()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var createdVulnerabilities = new List<VulnerabilityModel>();
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .Callback<VulnerabilityModel>(v => createdVulnerabilities.Add(v))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = createdVulnerabilities.Count; return v; });

        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert - Per contribution guidelines: use level 2 headings (##) for sections and ensure they are bolded
        foreach (var vuln in createdVulnerabilities)
        {
            // Check for bolded level 2 headings pattern: ## **Section**
            vuln.Description.Should().MatchRegex(@"##\s+\*\*\w+",
                "Sections should use level 2 headings (##) that are bolded (**) per contribution guidelines");
        }
    }

    #endregion

    #region Deduplication Tests

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithExistingSpikoVulnerabilities_SkipsDuplicates()
    {
        // Arrange
        SetupSpikoExtractionPipeline();

        // Add one existing vulnerability with matching title
        var existingVulns = new List<VulnerabilityModel>
        {
            new()
            {
                Id = 1,
                Title = "Incorrect Token Burn Source in Redemption Execution",
                Status = VulnerabilityModelStatus.Approved,
                ReportId = SpikoReportId
            }
        };
        _vulnerabilityProcessorMock.Setup(x => x.Search(It.IsAny<VulnerabilitySearchModel>()))
            .ReturnsAsync(existingVulns);

        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Ok>();
        var ok = (Result<VulnerabilityExtractionResultViewModel, string>.Ok)result;
        ok.Value.TotalExtracted.Should().Be(5);
        ok.Value.DuplicatesSkipped.Should().Be(1, "One vulnerability already exists");
        ok.Value.TotalCreated.Should().Be(4);
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithAllExistingVulnerabilities_SkipsAll()
    {
        // Arrange
        SetupSpikoExtractionPipeline();

        // All vulnerabilities already exist
        var existingVulns = GetSpikoExpectedVulnerabilities()
            .Select((v, i) => new VulnerabilityModel
            {
                Id = i + 1,
                Title = v.Title,
                Status = VulnerabilityModelStatus.Approved,
                ReportId = SpikoReportId
            })
            .ToList();

        _vulnerabilityProcessorMock.Setup(x => x.Search(It.IsAny<VulnerabilitySearchModel>()))
            .ReturnsAsync(existingVulns);

        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Ok>();
        var ok = (Result<VulnerabilityExtractionResultViewModel, string>.Ok)result;
        ok.Value.TotalExtracted.Should().Be(5);
        ok.Value.DuplicatesSkipped.Should().Be(5);
        ok.Value.TotalCreated.Should().Be(0);
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithCaseInsensitiveMatchingTitle_SkipsDuplicate()
    {
        // Arrange
        SetupSpikoExtractionPipeline();

        // Add existing vulnerability with different case
        var existingVulns = new List<VulnerabilityModel>
        {
            new()
            {
                Id = 1,
                Title = "INCORRECT TOKEN BURN SOURCE IN REDEMPTION EXECUTION",
                Status = VulnerabilityModelStatus.Approved,
                ReportId = SpikoReportId
            }
        };
        _vulnerabilityProcessorMock.Setup(x => x.Search(It.IsAny<VulnerabilitySearchModel>()))
            .ReturnsAsync(existingVulns);

        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Ok>();
        var ok = (Result<VulnerabilityExtractionResultViewModel, string>.Ok)result;
        ok.Value.DuplicatesSkipped.Should().BeGreaterThan(0, "Case-insensitive title matching should detect duplicate");
    }

    #endregion

    #region Tags Validation Tests

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_AssignsAppropriateTags()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var createdVulnerabilities = new List<VulnerabilityModel>();
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .Callback<VulnerabilityModel>(v => createdVulnerabilities.Add(v))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = createdVulnerabilities.Count; return v; });

        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert - At least some vulnerabilities should have tags
        createdVulnerabilities.Should().Contain(v => v.Tags != null && v.Tags.Count > 0,
            "Vulnerabilities should be assigned relevant tags");
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_TagsAreFromAvailableList()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var createdVulnerabilities = new List<VulnerabilityModel>();
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .Callback<VulnerabilityModel>(v => createdVulnerabilities.Add(v))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = createdVulnerabilities.Count; return v; });

        var availableTags = new List<string>
        {
            "Logic Bug", "Token Operations", "Access Control", "Configuration",
            "Gas Optimization", "Input Validation", "Best Practices", "Documentation"
        };

        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert
        foreach (var vuln in createdVulnerabilities.Where(v => v.Tags != null))
        {
            vuln.Tags!.Should().OnlyContain(tag => availableTags.Contains(tag),
                "Tags should only be from the available tags list");
        }
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_HighSeverityVulnsHaveLogicBugTag()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var createdVulnerabilities = new List<VulnerabilityModel>();
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .Callback<VulnerabilityModel>(v => createdVulnerabilities.Add(v))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = createdVulnerabilities.Count; return v; });

        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert - HAL-01 (Token burn logic flaw) should have Logic Bug tag
        var tokenBurnVuln = createdVulnerabilities.FirstOrDefault(v =>
            v.Title.Contains("Token Burn") || v.Title.Contains("Redemption Execution"));
        tokenBurnVuln.Should().NotBeNull();
        tokenBurnVuln!.Tags.Should().Contain("Logic Bug",
            "HAL-01 is a logic bug in token burn source");
    }

    #endregion

    #region Embedding Tests

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_GeneratesEmbeddingsForAllVulnerabilities()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert
        _embeddingServiceMock.Verify(
            x => x.GenerateEmbeddingForDocumentAsync(It.IsAny<string>()),
            Times.Exactly(5),
            "Should generate embeddings for all 5 Spiko vulnerabilities");
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_ContinuesWhenEmbeddingFails()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        _embeddingServiceMock.Setup(x => x.GenerateEmbeddingForDocumentAsync(It.IsAny<string>()))
            .ThrowsAsync(new Exception("Embedding service unavailable"));

        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert
        // Should still succeed but without embeddings
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Ok>();
        var ok = (Result<VulnerabilityExtractionResultViewModel, string>.Ok)result;
        ok.Value.TotalCreated.Should().Be(5, "Vulnerabilities should be created even if embeddings fail");
    }

    #endregion

    #region Specific Vulnerability Tests

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_ExtractsRedemptionBugCorrectly()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var createdVulnerabilities = new List<VulnerabilityModel>();
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .Callback<VulnerabilityModel>(v => createdVulnerabilities.Add(v))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = createdVulnerabilities.Count; return v; });

        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert - Verify HAL-01 details
        var redemptionBug = createdVulnerabilities.FirstOrDefault(v =>
            v.Title.Contains("Token Burn") || v.Title.Contains("Redemption"));
        redemptionBug.Should().NotBeNull("HAL-01 should be extracted");
        redemptionBug!.Severity.Should().Be(VulnerabilitySeverity.High);
        redemptionBug.Description.Should().Contain("execute_redemptions",
            "Should reference the affected function");
        redemptionBug.Description.Should().Contain("contracts/redemption/src/contract.rs",
            "Should reference the affected file");
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_ExtractsAdminRoleBugCorrectly()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var createdVulnerabilities = new List<VulnerabilityModel>();
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .Callback<VulnerabilityModel>(v => createdVulnerabilities.Add(v))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = createdVulnerabilities.Count; return v; });

        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert - Verify HAL-02 details
        var adminBug = createdVulnerabilities.FirstOrDefault(v =>
            v.Title.Contains("Admin") || v.Title.Contains("Unrecoverable"));
        adminBug.Should().NotBeNull("HAL-02 should be extracted");
        adminBug!.Severity.Should().Be(VulnerabilitySeverity.High);
        adminBug.Description.Should().Contain("renounce_admin",
            "Should reference the affected function");
        adminBug.Description.Should().Contain("AccessControl",
            "Should reference the AccessControl crate");
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSpikoReport_ExtractsIdempotencyBugCorrectly()
    {
        // Arrange
        SetupSpikoExtractionPipeline();
        var createdVulnerabilities = new List<VulnerabilityModel>();
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .Callback<VulnerabilityModel>(v => createdVulnerabilities.Add(v))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = createdVulnerabilities.Count; return v; });

        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(SpikoReportId);

        // Assert - Verify HAL-03 details
        var idempotencyBug = createdVulnerabilities.FirstOrDefault(v =>
            v.Title.Contains("Idempotency") || v.Title.Contains("No-Op"));
        idempotencyBug.Should().NotBeNull("HAL-03 should be extracted");
        idempotencyBug!.Severity.Should().Be(VulnerabilitySeverity.Medium);
        idempotencyBug.Description.Should().Contain("contracts/token/src/contract.rs",
            "Should reference the affected file");
    }

    #endregion

    #region Helper Methods

    private VulnerabilityExtractionService CreateService()
    {
        return new VulnerabilityExtractionService(
            _agentServiceMock.Object,
            _reportProcessorMock.Object,
            _vulnerabilityProcessorMock.Object,
            _categoryProcessorMock.Object,
            _embeddingServiceMock.Object,
            _userContextAccessorMock.Object,
            _loggerMock.Object);
    }

    private void SetupSpikoExtractionPipeline()
    {
        // Setup report
        var report = new ReportModel
        {
            Id = SpikoReportId,
            Name = "Stellar Contracts - Spiko",
            MdFile = GetSpikoReportMarkdown(),
            Status = ReportModelStatus.Approved,
            Date = new DateTime(2025, 10, 3)
        };
        _reportProcessorMock.Setup(x => x.Get(SpikoReportId)).ReturnsAsync(report);

        // Setup existing vulnerabilities (empty - no duplicates)
        _vulnerabilityProcessorMock.Setup(x => x.Search(It.IsAny<VulnerabilitySearchModel>()))
            .ReturnsAsync(new List<VulnerabilityModel>());

        // Setup example vulnerabilities
        var examples = new List<VulnerabilityModel>
        {
            new() { Id = 1, Title = "Example Vuln", Status = VulnerabilityModelStatus.Approved, Severity = VulnerabilitySeverity.High, Tags = new List<string> { "Example" } }
        };
        _vulnerabilityProcessorMock.Setup(x => x.GetList()).ReturnsAsync(examples);

        // Setup categories
        var categories = new List<CategoryModel>
        {
            new() { Id = 1, Name = "Logic Bug" },
            new() { Id = 2, Name = "Token Operations" },
            new() { Id = 3, Name = "Access Control" },
            new() { Id = 4, Name = "Configuration" },
            new() { Id = 5, Name = "Gas Optimization" },
            new() { Id = 6, Name = "Input Validation" },
            new() { Id = 7, Name = "Best Practices" },
            new() { Id = 8, Name = "Documentation" }
        };
        _categoryProcessorMock.Setup(x => x.List()).ReturnsAsync(categories);

        // Setup user context
        _userContextAccessorMock.Setup(x => x.GetLoginIdAsync()).ReturnsAsync(1);

        // Setup Parser Agent
        var parserResponse = new ParserAgentResponse
        {
            Sections = new List<VulnerabilitySection>
            {
                new() { Id = 1, Title = "HAL-01: Incorrect Token Burn Source in Redemption Execution", StartLine = 20, EndLine = 45 },
                new() { Id = 2, Title = "HAL-02: Unrecoverable Admin Role Removal", StartLine = 47, EndLine = 70 },
                new() { Id = 3, Title = "HAL-03: Idempotency Keys Consumed on No-Op Operations", StartLine = 72, EndLine = 95 },
                new() { Id = 4, Title = "HAL-04: Fixed Initialization Logic in Separate Function", StartLine = 97, EndLine = 118 },
                new() { Id = 5, Title = "HAL-05: Inadequate In-Code Documentation", StartLine = 120, EndLine = 138 }
            },
            Metadata = new ReportMetadata
            {
                TotalFindings = 5,
                AuditScope = "Spiko Stellar Contracts - Token Redemption and Permission Management"
            }
        };
        _agentServiceMock.Setup(x => x.CallAgentAsync(AgentType.Parser, It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new Result<string, string>.Ok(JsonSerializer.Serialize(parserResponse)));

        // Setup Extractor Agent
        var extractorResponse = new ExtractorAgentResponse
        {
            Vulnerabilities = GetSpikoExpectedVulnerabilities()
                .Select(v => new RawVulnerability
                {
                    SectionId = v.SectionId,
                    Title = v.Title,
                    Description = v.Description,
                    Impact = v.Impact,
                    Recommendation = v.Recommendation,
                    Location = v.Location
                })
                .ToList()
        };
        _agentServiceMock.Setup(x => x.CallAgentAsync(AgentType.Extractor, It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new Result<string, string>.Ok(JsonSerializer.Serialize(extractorResponse)));

        // Setup Classifier Agent
        var classifierResponse = new ClassifierAgentResponse
        {
            Vulnerabilities = GetSpikoExpectedVulnerabilities()
        };
        _agentServiceMock.Setup(x => x.CallAgentAsync(AgentType.Classifier, It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new Result<string, string>.Ok(JsonSerializer.Serialize(classifierResponse)));

        // Setup vulnerability creation
        var vulnId = 1;
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = vulnId++; return v; });

        // Setup embedding generation
        _embeddingServiceMock.Setup(x => x.GenerateEmbeddingForDocumentAsync(It.IsAny<string>()))
            .ReturnsAsync(new float[] { 0.1f, 0.2f, 0.3f });
    }

    #endregion
}
