using System.Text.Json;
using Microsoft.Extensions.Logging;
using Pgvector;
using SorobanSecurityPortalApi.Common;
using SorobanSecurityPortalApi.Data.Processors;
using SorobanSecurityPortalApi.Models.DbModels;
using SorobanSecurityPortalApi.Models.ViewModels;
using SorobanSecurityPortalApi.Services.AgentServices;
using SorobanSecurityPortalApi.Services.AgentServices.Types;

namespace SorobanSecurityPortalApi.Tests.Services.AgentServices;

/// <summary>
/// Unit tests for VulnerabilityExtractionService.
/// Tests cover the full extraction pipeline, null report handling, markdown size validation,
/// deduplication logic (Jaccard similarity), vulnerability creation with embeddings, and error handling.
/// </summary>
public class VulnerabilityExtractionServiceTests
{
    private readonly Mock<IGeminiAgentService> _agentServiceMock;
    private readonly Mock<IReportProcessor> _reportProcessorMock;
    private readonly Mock<IVulnerabilityProcessor> _vulnerabilityProcessorMock;
    private readonly Mock<ICategoryProcessor> _categoryProcessorMock;
    private readonly Mock<IGeminiEmbeddingService> _embeddingServiceMock;
    private readonly Mock<IUserContextAccessor> _userContextAccessorMock;
    private readonly Mock<ILogger<VulnerabilityExtractionService>> _loggerMock;

    public VulnerabilityExtractionServiceTests()
    {
        _agentServiceMock = new Mock<IGeminiAgentService>();
        _reportProcessorMock = new Mock<IReportProcessor>();
        _vulnerabilityProcessorMock = new Mock<IVulnerabilityProcessor>();
        _categoryProcessorMock = new Mock<ICategoryProcessor>();
        _embeddingServiceMock = new Mock<IGeminiEmbeddingService>();
        _userContextAccessorMock = new Mock<IUserContextAccessor>();
        _loggerMock = new Mock<ILogger<VulnerabilityExtractionService>>();
    }

    #region Report Not Found Tests

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WhenReportNotFound_ReturnsError()
    {
        // Arrange
        _reportProcessorMock.Setup(x => x.Get(It.IsAny<int>()))
            .ReturnsAsync((ReportModel?)null);
        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(999);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Err>();
        var err = (Result<VulnerabilityExtractionResultViewModel, string>.Err)result;
        err.Error.Should().Be("Report with ID 999 not found.");
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithNullReport_ReturnsError()
    {
        // Arrange
        _reportProcessorMock.Setup(x => x.Get(42))
            .ReturnsAsync((ReportModel?)null);
        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(42);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Err>();
        var err = (Result<VulnerabilityExtractionResultViewModel, string>.Err)result;
        err.Error.Should().Contain("not found");
    }

    #endregion

    #region Markdown Content Validation Tests

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WhenMarkdownIsNull_ReturnsError()
    {
        // Arrange
        var report = CreateReport(id: 1, mdFile: null);
        _reportProcessorMock.Setup(x => x.Get(1)).ReturnsAsync(report);
        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(1);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Err>();
        var err = (Result<VulnerabilityExtractionResultViewModel, string>.Err)result;
        err.Error.Should().Be("Report does not have markdown content for extraction.");
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WhenMarkdownIsEmpty_ReturnsError()
    {
        // Arrange
        var report = CreateReport(id: 1, mdFile: "");
        _reportProcessorMock.Setup(x => x.Get(1)).ReturnsAsync(report);
        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(1);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Err>();
        var err = (Result<VulnerabilityExtractionResultViewModel, string>.Err)result;
        err.Error.Should().Be("Report does not have markdown content for extraction.");
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WhenMarkdownIsWhitespace_ReturnsError()
    {
        // Arrange
        var report = CreateReport(id: 1, mdFile: "   \n\t  ");
        _reportProcessorMock.Setup(x => x.Get(1)).ReturnsAsync(report);
        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(1);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Err>();
        var err = (Result<VulnerabilityExtractionResultViewModel, string>.Err)result;
        err.Error.Should().Be("Report does not have markdown content for extraction.");
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WhenMarkdownExceedsSizeLimit_ReturnsError()
    {
        // Arrange
        // 6MB of content (exceeds 5MB limit)
        var largeMarkdown = new string('x', 6 * 1024 * 1024);
        var report = CreateReport(id: 1, mdFile: largeMarkdown);
        _reportProcessorMock.Setup(x => x.Get(1)).ReturnsAsync(report);
        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(1);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Err>();
        var err = (Result<VulnerabilityExtractionResultViewModel, string>.Err)result;
        err.Error.Should().Contain("too large");
        err.Error.Should().Contain("5MB");
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WhenMarkdownIsWithinSizeLimit_Proceeds()
    {
        // Arrange
        var validMarkdown = new string('x', 4 * 1024 * 1024); // 4MB
        SetupSuccessfulExtractionPipeline(mdFile: validMarkdown);
        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(1);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Ok>();
    }

    #endregion

    #region Agent Pipeline Tests

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WhenParserAgentFails_ReturnsResultWithError()
    {
        // Arrange
        SetupReportWithMarkdown();
        SetupExistingVulnerabilities();
        SetupExampleVulnerabilities();
        SetupCategories();
        _agentServiceMock.Setup(x => x.CallAgentAsync(AgentType.Parser, It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new Result<string, string>.Err("Parser failed"));
        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(1);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Ok>();
        var ok = (Result<VulnerabilityExtractionResultViewModel, string>.Ok)result;
        ok.Value.ProcessingErrors.Should().Contain(e => e.Contains("Parser Agent failed"));
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WhenExtractorAgentFails_ReturnsResultWithError()
    {
        // Arrange
        SetupReportWithMarkdown();
        SetupExistingVulnerabilities();
        SetupExampleVulnerabilities();
        SetupCategories();
        SetupParserAgentSuccess();
        _agentServiceMock.Setup(x => x.CallAgentAsync(AgentType.Extractor, It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new Result<string, string>.Err("Extractor failed"));
        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(1);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Ok>();
        var ok = (Result<VulnerabilityExtractionResultViewModel, string>.Ok)result;
        ok.Value.ProcessingErrors.Should().Contain(e => e.Contains("Extractor Agent failed"));
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WhenClassifierAgentFails_ContinuesWithDefaultClassification()
    {
        // Arrange
        SetupReportWithMarkdown();
        SetupExistingVulnerabilities(new List<VulnerabilityModel>());
        SetupExampleVulnerabilities();
        SetupCategories();
        SetupUserContext();
        SetupParserAgentSuccess();
        SetupExtractorAgentSuccess();
        // Classifier fails
        _agentServiceMock.Setup(x => x.CallAgentAsync(AgentType.Classifier, It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new Result<string, string>.Err("Classifier failed"));
        // Setup vulnerability creation
        var vulnId = 1;
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = vulnId++; return v; });
        _embeddingServiceMock.Setup(x => x.GenerateEmbeddingForDocumentAsync(It.IsAny<string>()))
            .ReturnsAsync(new float[] { 0.1f, 0.2f, 0.3f });
        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(1);

        // Assert
        // Classification is optional - extraction should still succeed with warnings
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Ok>();
        var ok = (Result<VulnerabilityExtractionResultViewModel, string>.Ok)result;
        ok.Value.ValidationWarnings.Should().Contain(e => e.Contains("Classification skipped"));
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WhenNoVulnerabilitiesFound_ReturnsEmptyResult()
    {
        // Arrange
        SetupReportWithMarkdown();
        SetupExistingVulnerabilities();
        SetupExampleVulnerabilities();
        SetupCategories();
        // Parser returns no sections
        var emptyParserResponse = new ParserAgentResponse { Sections = new List<VulnerabilitySection>() };
        _agentServiceMock.Setup(x => x.CallAgentAsync(AgentType.Parser, It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new Result<string, string>.Ok(JsonSerializer.Serialize(emptyParserResponse)));
        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(1);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Ok>();
        var ok = (Result<VulnerabilityExtractionResultViewModel, string>.Ok)result;
        ok.Value.TotalExtracted.Should().Be(0);
        ok.Value.TotalCreated.Should().Be(0);
        ok.Value.ValidationWarnings.Should().Contain(w => w.Contains("No vulnerability sections found"));
    }

    #endregion

    #region Full Pipeline Success Tests

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WithSuccessfulPipeline_CreatesVulnerabilities()
    {
        // Arrange
        SetupSuccessfulExtractionPipeline();
        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(1);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Ok>();
        var ok = (Result<VulnerabilityExtractionResultViewModel, string>.Ok)result;
        ok.Value.TotalExtracted.Should().Be(2);
        ok.Value.TotalCreated.Should().Be(2);
        ok.Value.DuplicatesSkipped.Should().Be(0);
        ok.Value.CreatedVulnerabilityIds.Should().HaveCount(2);
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_CreatesVulnerabilityWithCorrectData()
    {
        // Arrange
        SetupSuccessfulExtractionPipeline();
        VulnerabilityModel? createdVulnerability = null;
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .Callback<VulnerabilityModel>(v => createdVulnerability = v)
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = 100; return v; });
        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(1);

        // Assert
        createdVulnerability.Should().NotBeNull();
        createdVulnerability!.Title.Should().NotBeNullOrEmpty();
        createdVulnerability.ReportId.Should().Be(1);
        createdVulnerability.Status.Should().Be(VulnerabilityModelStatus.New);
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_GeneratesEmbeddingsForVulnerabilities()
    {
        // Arrange
        SetupSuccessfulExtractionPipeline();
        var sut = CreateService();

        // Act
        await sut.ExtractVulnerabilitiesAsync(1);

        // Assert
        _embeddingServiceMock.Verify(
            x => x.GenerateEmbeddingForDocumentAsync(It.IsAny<string>()),
            Times.AtLeastOnce());
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_ContinuesWhenEmbeddingFails()
    {
        // Arrange
        SetupSuccessfulExtractionPipeline();
        _embeddingServiceMock.Setup(x => x.GenerateEmbeddingForDocumentAsync(It.IsAny<string>()))
            .ThrowsAsync(new Exception("Embedding service unavailable"));
        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(1);

        // Assert
        // Should still succeed but without embeddings
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Ok>();
        var ok = (Result<VulnerabilityExtractionResultViewModel, string>.Ok)result;
        ok.Value.TotalCreated.Should().BeGreaterThan(0);
    }

    #endregion

    #region Deduplication Tests

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_SkipsExactDuplicateTitles()
    {
        // Arrange
        SetupSuccessfulExtractionPipeline();
        // Setup existing vulnerability with same title as one being extracted
        var existingVulnerabilities = new List<VulnerabilityModel>
        {
            new() { Id = 1, Title = "Critical: Reentrancy Attack", Status = VulnerabilityModelStatus.Approved }
        };
        _vulnerabilityProcessorMock.Setup(x => x.Search(It.IsAny<VulnerabilitySearchModel>()))
            .ReturnsAsync(existingVulnerabilities);
        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(1);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Ok>();
        var ok = (Result<VulnerabilityExtractionResultViewModel, string>.Ok)result;
        ok.Value.DuplicatesSkipped.Should().BeGreaterThan(0);
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_SkipsSimilarTitlesAboveThreshold()
    {
        // Arrange
        SetupSuccessfulExtractionPipeline();
        // "Critical: Reentrancy Attack" vs "Critical: Reentrancy Attack Vulnerability"
        // These should be similar enough to trigger deduplication
        var existingVulnerabilities = new List<VulnerabilityModel>
        {
            new() { Id = 1, Title = "Critical Reentrancy Attack Vulnerability", Status = VulnerabilityModelStatus.Approved }
        };
        _vulnerabilityProcessorMock.Setup(x => x.Search(It.IsAny<VulnerabilitySearchModel>()))
            .ReturnsAsync(existingVulnerabilities);
        var sut = CreateService();
        var result = await sut.ExtractVulnerabilitiesAsync(1, new VulnerabilityExtractionOptions { MaxVulnerabilities = 15 });

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Ok>();
    }

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_AllowsDifferentTitles()
    {
        // Arrange
        SetupSuccessfulExtractionPipeline();
        // Completely different existing vulnerability
        var existingVulnerabilities = new List<VulnerabilityModel>
        {
            new() { Id = 1, Title = "Completely Unrelated Issue", Status = VulnerabilityModelStatus.Approved }
        };
        _vulnerabilityProcessorMock.Setup(x => x.Search(It.IsAny<VulnerabilitySearchModel>()))
            .ReturnsAsync(existingVulnerabilities);
        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(1);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Ok>();
        var ok = (Result<VulnerabilityExtractionResultViewModel, string>.Ok)result;
        ok.Value.TotalCreated.Should().Be(ok.Value.TotalExtracted);
        ok.Value.DuplicatesSkipped.Should().Be(0);
    }

    #endregion

    #region Cancellation Token Tests

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_RespectsCancellationToken()
    {
        // Arrange
        SetupReportWithMarkdown();
        SetupExistingVulnerabilities();
        SetupExampleVulnerabilities();
        SetupCategories();
        SetupParserAgentSuccess();
        SetupExtractorAgentSuccess();
        SetupClassifierAgentSuccess();
        SetupUserContext();

        using var cts = new CancellationTokenSource();
        cts.Cancel();

        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = 1; return v; });
        _embeddingServiceMock.Setup(x => x.GenerateEmbeddingForDocumentAsync(It.IsAny<string>()))
            .ReturnsAsync(new float[] { 0.1f, 0.2f, 0.3f });

        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(1, null, cts.Token);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Err>();
        var err = (Result<VulnerabilityExtractionResultViewModel, string>.Err)result;
        err.Error.Should().Contain("cancel");
    }

    #endregion

    #region Processing Time Tests

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_RecordsProcessingTime()
    {
        // Arrange
        SetupSuccessfulExtractionPipeline();
        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(1);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Ok>();
        var ok = (Result<VulnerabilityExtractionResultViewModel, string>.Ok)result;
        ok.Value.ProcessingTimeMs.Should().BeGreaterOrEqualTo(0);
    }

    #endregion

    #region Exception Handling Tests

    [Fact]
    public async Task ExtractVulnerabilitiesAsync_WhenExceptionOccurs_ReturnsError()
    {
        // Arrange
        _reportProcessorMock.Setup(x => x.Get(It.IsAny<int>()))
            .ThrowsAsync(new InvalidOperationException("Database connection failed"));
        var sut = CreateService();

        // Act
        var result = await sut.ExtractVulnerabilitiesAsync(1);

        // Assert
        result.Should().BeOfType<Result<VulnerabilityExtractionResultViewModel, string>.Err>();
        var err = (Result<VulnerabilityExtractionResultViewModel, string>.Err)result;
        err.Error.Should().Contain("Database connection failed");
    }

    #endregion

    #region Helper Methods

    private VulnerabilityExtractionService CreateService()
    {
        return new VulnerabilityExtractionService(
            _agentServiceMock.Object,
            _reportProcessorMock.Object,
            _vulnerabilityProcessorMock.Object,
            _categoryProcessorMock.Object,
            _embeddingServiceMock.Object,
            _userContextAccessorMock.Object,
            _loggerMock.Object);
    }

    private static ReportModel CreateReport(int id = 1, string? mdFile = "# Test Report\n\nSome content")
    {
        return new ReportModel
        {
            Id = id,
            Name = "Test Report",
            MdFile = mdFile,
            Status = ReportModelStatus.Approved,
            Date = DateTime.UtcNow
        };
    }

    private void SetupReportWithMarkdown(string? mdFile = "# Test Report\n\n## Vulnerability 1\n\nDescription here")
    {
        var report = CreateReport(mdFile: mdFile);
        _reportProcessorMock.Setup(x => x.Get(1)).ReturnsAsync(report);
    }

    private void SetupExistingVulnerabilities(List<VulnerabilityModel>? vulnerabilities = null)
    {
        _vulnerabilityProcessorMock.Setup(x => x.Search(It.IsAny<VulnerabilitySearchModel>()))
            .ReturnsAsync(vulnerabilities ?? new List<VulnerabilityModel>());
    }

    private void SetupExampleVulnerabilities()
    {
        var examples = new List<VulnerabilityModel>
        {
            new() { Id = 1, Title = "Example 1", Status = VulnerabilityModelStatus.Approved, Severity = "high", Tags = new List<string> { "reentrancy" } },
            new() { Id = 2, Title = "Example 2", Status = VulnerabilityModelStatus.Approved, Severity = "medium", Tags = new List<string> { "overflow" } }
        };
        _vulnerabilityProcessorMock.Setup(x => x.GetList()).ReturnsAsync(examples);
    }

    private void SetupCategories()
    {
        var categories = new List<CategoryModel>
        {
            new() { Id = 1, Name = "Reentrancy" },
            new() { Id = 2, Name = "Integer Overflow" }
        };
        _categoryProcessorMock.Setup(x => x.List()).ReturnsAsync(categories);
    }

    private void SetupUserContext()
    {
        _userContextAccessorMock.Setup(x => x.GetLoginIdAsync()).ReturnsAsync(1);
    }

    private void SetupParserAgentSuccess()
    {
        var parserResponse = new ParserAgentResponse
        {
            Sections = new List<VulnerabilitySection>
            {
                new() { Id = 1, Title = "Vulnerability 1", StartLine = 10, EndLine = 20 },
                new() { Id = 2, Title = "Vulnerability 2", StartLine = 25, EndLine = 35 }
            }
        };
        _agentServiceMock.Setup(x => x.CallAgentAsync(AgentType.Parser, It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new Result<string, string>.Ok(JsonSerializer.Serialize(parserResponse)));
    }

    private void SetupExtractorAgentSuccess()
    {
        var extractorResponse = new ExtractorAgentResponse
        {
            Vulnerabilities = new List<RawVulnerability>
            {
                new() { SectionId = "1", Title = "Critical: Reentrancy Attack", Description = "An attacker can...", Impact = "Loss of funds" },
                new() { SectionId = "2", Title = "Integer Overflow in calculateBalance", Description = "The function...", Impact = "Incorrect balances" }
            }
        };
        _agentServiceMock.Setup(x => x.CallAgentAsync(AgentType.Extractor, It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new Result<string, string>.Ok(JsonSerializer.Serialize(extractorResponse)));
    }

    private void SetupClassifierAgentSuccess()
    {
        var classifierResponse = new ClassifierAgentResponse
        {
            Vulnerabilities = new List<ClassifiedVulnerability>
            {
                new() { Title = "Critical: Reentrancy Attack", Description = "An attacker can...", Severity = "critical", Tags = new List<string> { "reentrancy" }, Category = 1 },
                new() { Title = "Integer Overflow in calculateBalance", Description = "The function...", Severity = "high", Tags = new List<string> { "overflow" }, Category = 2 }
            }
        };
        _agentServiceMock.Setup(x => x.CallAgentAsync(AgentType.Classifier, It.IsAny<string>(), It.IsAny<CancellationToken>()))
            .ReturnsAsync(new Result<string, string>.Ok(JsonSerializer.Serialize(classifierResponse)));
    }

    private void SetupSuccessfulExtractionPipeline(string? mdFile = "# Test Report")
    {
        SetupReportWithMarkdown(mdFile);
        SetupExistingVulnerabilities(new List<VulnerabilityModel>());
        SetupExampleVulnerabilities();
        SetupCategories();
        SetupUserContext();
        SetupParserAgentSuccess();
        SetupExtractorAgentSuccess();
        SetupClassifierAgentSuccess();

        var vulnId = 1;
        _vulnerabilityProcessorMock.Setup(x => x.Add(It.IsAny<VulnerabilityModel>()))
            .ReturnsAsync((VulnerabilityModel v) => { v.Id = vulnId++; return v; });

        _embeddingServiceMock.Setup(x => x.GenerateEmbeddingForDocumentAsync(It.IsAny<string>()))
            .ReturnsAsync(new float[] { 0.1f, 0.2f, 0.3f });
    }

    #endregion
}
