using SorobanSecurityPortalApi.Common.Data;
using SorobanSecurityPortalApi.Models.DbModels;
using Microsoft.EntityFrameworkCore;
using Pgvector;
using Pgvector.EntityFrameworkCore;
using static SorobanSecurityPortalApi.Common.ExceptionHandlingMiddleware;
using SorobanSecurityPortalApi.Common.Extensions;
using SorobanSecurityPortalApi.Common;

namespace SorobanSecurityPortalApi.Data.Processors
{
    public class VulnerabilityProcessor : IVulnerabilityProcessor
    {
        private readonly Db _db;
        private readonly ExtendedConfig _extendedConfig;

        public VulnerabilityProcessor(Db db, ExtendedConfig extendedConfig)
        {
            _db = db;
            _extendedConfig = extendedConfig;
        }

        public async Task<List<VulnerabilityModel>> Search(VulnerabilitySearchModel? s)
        {
            var query = BuildFilteredQuery(s);
            if (s == null || string.IsNullOrWhiteSpace(s.SearchText))
            {
                query = ApplySorting(query, s?.SortBy, s?.SortDirection) ?? query.OrderByDescending(v => v.Id);
            }
            var page = s?.Page is > 0 ? s.Page!.Value : 1;
            var pageSize = s?.PageSize is > 0 ? s.PageSize!.Value : 20;

            return await query
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();
        }

        public async Task<int> SearchTotal(VulnerabilitySearchModel? s)
        {
            var query = BuildFilteredQuery(s);
            return await query.CountAsync();
        }

        private IQueryable<VulnerabilityModel> BuildFilteredQuery(VulnerabilitySearchModel? s)
        {
            var query = _db.Vulnerability
                .AsNoTracking()
                .Where(v => v.Status == VulnerabilityModelStatus.Approved);

            if (s == null) return query;

            if (s.From is not null)
            {
                var fromUtc = s.From.Value.Kind == DateTimeKind.Utc ? s.From.Value : s.From.Value.ToUniversalTime();
                query = query.Where(v => v.Date >= fromUtc);
            }

            if (s.To is not null)
            {
                var toUtc = s.To.Value.Kind == DateTimeKind.Utc ? s.To.Value : s.To.Value.ToUniversalTime();
                query = query.Where(v => v.Date <= toUtc);
            }

            // Build a single scoring expression
            if (!string.IsNullOrWhiteSpace(s.SearchText) || s.Embedding is not null)
            {
                var searchText = s.SearchText ?? "";
                var queryEmbedding = s.Embedding;

                query = query
                    .Select(v => new
                    {
                        v,
                        TextScore =
                        (string.IsNullOrEmpty(searchText)
                        ? 0.0
                                : (TrigramExtensions.TrigramSimilarity(v.Title, searchText) * _extendedConfig.TrigramNameWeight
                                   + TrigramExtensions.TrigramSimilarity(v.Description, searchText) * _extendedConfig.TrigramContentWeight)),
                        VecScore =
                            (queryEmbedding == null || v.Embedding == null)
                        ? 0.0
                                : (1.0 - v.Embedding.CosineDistance(queryEmbedding!)) * _extendedConfig.VectorContentWeight
                    })
                    .Where(x => _extendedConfig.MinRelevanceForSearch < (x.TextScore + x.VecScore))
                    .OrderByDescending(x => x.TextScore + x.VecScore)
                    .Select(x => x.v);
            }

            if (s.Companies is { Count: > 0 })
                query = query.Where(v => s.Companies.Contains(v.Company));

            if (s.Sources is { Count: > 0 })
                query = query.Where(v => s.Sources.Contains(v.Source));

            if (s.Auditors is { Count: > 0 })
                query = query.Where(v => s.Auditors.Contains(v.Auditor));

            if (s.Protocols is { Count: > 0 })
                query = query.Where(v => s.Protocols.Contains(v.Protocol));

            if (s.Severities is { Count: > 0 })
                query = query.Where(v => s.Severities.Contains(v.Severity));

            if (s.Categories is { Count: > 0 })
                query = query.Where(v => v.Categories != null && v.Categories.Any(c => s.Categories.Contains(c)));

            return query;
        }

        private static IOrderedQueryable<VulnerabilityModel>? ApplySorting(
            IQueryable<VulnerabilityModel> query,
            string? sortBy,
            string? sortDirection)
        {
            if (string.IsNullOrWhiteSpace(sortBy)) return null;

            var asc = string.Equals(sortDirection, "asc", StringComparison.OrdinalIgnoreCase);

            return sortBy.ToLowerInvariant() switch
            {
                "date" => asc ? query.OrderBy(v => v.Date) : query.OrderByDescending(v => v.Date),
                "severity" => asc ? query.OrderBy(v => v.Severity) : query.OrderByDescending(v => v.Severity),
                "company" => asc ? query.OrderBy(v => v.Company) : query.OrderByDescending(v => v.Company),
                "source" => asc ? query.OrderBy(v => v.Source) : query.OrderByDescending(v => v.Source),
                "protocol" => asc ? query.OrderBy(v => v.Protocol) : query.OrderByDescending(v => v.Protocol),
                "title" => asc ? query.OrderBy(v => v.Title) : query.OrderByDescending(v => v.Title),
                "description" => asc ? query.OrderBy(v => v.Description) : query.OrderByDescending(v => v.Description),
                _ => null
            };
        }


        public async Task<VulnerabilityModel> Add(VulnerabilityModel vulnerabilityModel)
        {
            if (vulnerabilityModel == null)
                throw new ArgumentNullException(nameof(vulnerabilityModel));
            vulnerabilityModel.Status = VulnerabilityModelStatus.New;
            _db.Vulnerability.Add(vulnerabilityModel);
            await _db.SaveChangesAsync();
            return vulnerabilityModel;
        }

        public async Task<VulnerabilityModel> Edit(VulnerabilityModel vulnerabilityModel, string userName)
        {
            if (vulnerabilityModel.Id == 0) throw new ArgumentException("Identifier mustn't be zero");
            var existing = await _db.Vulnerability.FirstAsync(item => item.Id == vulnerabilityModel.Id);
            _db.Entry(existing).CurrentValues.SetValues(vulnerabilityModel);
            existing.LastActionBy = userName;
            existing.LastActionAt = DateTime.UtcNow;
            _db.Vulnerability.Update(existing);
            await _db.SaveChangesAsync();
            return existing;
        }

        public async Task Approve(int vulnerabilityId, string userName)
        {
            var existing = await _db.Vulnerability.FirstAsync(item => item.Id == vulnerabilityId);
            existing.Status = VulnerabilityModelStatus.Approved;
            existing.LastActionBy = userName;
            existing.LastActionAt = DateTime.UtcNow;
            _db.Vulnerability.Update(existing);
            await _db.SaveChangesAsync();
        }

        public async Task Reject(int vulnerabilityId, string userName)
        {
            var existing = await _db.Vulnerability.FirstAsync(item => item.Id == vulnerabilityId);
            existing.Status = VulnerabilityModelStatus.Rejected;
            existing.LastActionBy = userName;
            existing.LastActionAt = DateTime.UtcNow;
            _db.Vulnerability.Update(existing);
            await _db.SaveChangesAsync();
        }

        public async Task Remove(int vulnerabilityId)
        {
            var existing = await _db.Vulnerability.FirstAsync(item => item.Id == vulnerabilityId);
            if (existing == null)
                return;
            _db.Vulnerability.Remove(existing);
            await _db.SaveChangesAsync();
        }

        public async Task<VulnerabilityModel> Get(int vulnerabilityId)
        {
            return await _db.Vulnerability
                .AsNoTracking()
                .FirstOrDefaultAsync(v => v.Id == vulnerabilityId);
        }

        public async Task<VulnerabilityModel> Update(string userName, VulnerabilityModel vulnerabilityModel)
        {
            if (vulnerabilityModel == null)
                throw new ArgumentNullException(nameof(vulnerabilityModel));
            var existing = await _db.Vulnerability.FirstAsync(item => item.Id == vulnerabilityModel.Id);
            _db.Entry(existing).CurrentValues.SetValues(vulnerabilityModel);
            existing.LastActionBy = userName;
            existing.LastActionAt = DateTime.UtcNow;
            _db.Vulnerability.Update(existing);
            await _db.SaveChangesAsync();
            return existing;
        }

        public async Task<List<VulnerabilityModel>> GetList()
        {
            return await _db.Vulnerability
                .AsNoTracking()
                .OrderByDescending(v => v.Id)
                .ToListAsync();
        }

        public async Task<List<VulnerabilityModel>> GetListForEmbedding()
        {
            return await _db.Vulnerability
                .AsNoTracking()
                .Where(v => v.Embedding == null)
                .OrderByDescending(v => v.Id)
                .ToListAsync();
        }

        public async Task UpdateEmbedding(int vulnerabilityId, Vector embedding)
        {
            var existing = await _db.Vulnerability.FirstAsync(item => item.Id == vulnerabilityId);
            if (existing == null)
                throw new SorobanSecurityPortalUiException($"Vulnerability with ID {vulnerabilityId} not found.");
            existing.Embedding = embedding;
            _db.Vulnerability.Update(existing);
            await _db.SaveChangesAsync();
        }
    }

    public interface IVulnerabilityProcessor
    {
        Task<List<VulnerabilityModel>> Search(VulnerabilitySearchModel vulnerabilitySearch);
        Task<int> SearchTotal(VulnerabilitySearchModel vulnerabilitySearch);
        Task<VulnerabilityModel> Add(VulnerabilityModel vulnerabilityModel);
        Task<VulnerabilityModel> Edit(VulnerabilityModel vulnerabilityModel, string userName);
        Task Approve(int vulnerabilityId, string userName);
        Task Reject(int vulnerabilityId, string userName);
        Task Remove(int vulnerabilityId);
        Task<VulnerabilityModel> Get(int vulnerabilityId);
        Task<VulnerabilityModel> Update(string userName, VulnerabilityModel vulnerabilityModel);
        Task<List<VulnerabilityModel>> GetList();
        Task<List<VulnerabilityModel>> GetListForEmbedding();
        Task UpdateEmbedding(int vulnerabilityId, Vector embedding);
    }
}