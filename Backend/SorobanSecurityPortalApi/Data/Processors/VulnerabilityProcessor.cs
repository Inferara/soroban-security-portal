using SorobanSecurityPortalApi.Common.Data;
using SorobanSecurityPortalApi.Models.DbModels;
using Microsoft.EntityFrameworkCore;

namespace SorobanSecurityPortalApi.Data.Processors
{
    public class VulnerabilityProcessor : IVulnerabilityProcessor
    {
        private readonly Db _db;

        public VulnerabilityProcessor(Db db)
        {
            _db = db;
        }

        public async Task<List<VulnerabilityModel>> Search(VulnerabilitySearchModel? vulnerabilitySearch)
        {
            var query = _db.Vulnerability.AsNoTracking().Where(v => v.Status == VulnerabilityModelStatus.Approved);

            if (vulnerabilitySearch != null)
            {
                if (vulnerabilitySearch.From != null)
                {
                    var from = DateTime.SpecifyKind(vulnerabilitySearch.From.Value, DateTimeKind.Utc);
                    query = query.Where(v => v.Date > from);
                }
                if (vulnerabilitySearch.To != null)
                {
                    var to = DateTime.SpecifyKind(vulnerabilitySearch.To.Value, DateTimeKind.Utc);
                    query = query.Where(v => v.Date < to);
                }
                if (!string.IsNullOrEmpty(vulnerabilitySearch.SearchText))
                {
                    query = query.Where(v =>
                        v.Title.Contains(vulnerabilitySearch.SearchText) ||
                        v.Description.Contains(vulnerabilitySearch.SearchText));
                }
                if (vulnerabilitySearch.Companies != null && vulnerabilitySearch.Companies.Count > 0)
                {
                    query = query.Where(v => vulnerabilitySearch.Companies.Contains(v.Company));
                }
                if (vulnerabilitySearch.Sources != null && vulnerabilitySearch.Sources.Count > 0)
                {
                    query = query.Where(v => vulnerabilitySearch.Sources.Contains(v.Source));
                }
                if (vulnerabilitySearch.Auditors != null && vulnerabilitySearch.Auditors.Count > 0)
                {
                    query = query.Where(v => vulnerabilitySearch.Auditors.Contains(v.Auditor));
                }
                if (vulnerabilitySearch.Protocols != null && vulnerabilitySearch.Protocols.Count > 0)
                {
                    query = query.Where(v => vulnerabilitySearch.Protocols.Contains(v.Protocol));
                }
                if (vulnerabilitySearch.Severities != null && vulnerabilitySearch.Severities.Count > 0)
                {
                    query = query.Where(v => vulnerabilitySearch.Severities.Contains(v.Severity));
                }
                if (vulnerabilitySearch.SortBy != null)
                {
                    switch (vulnerabilitySearch.SortBy)
                    {
                        case "date":
                            query = vulnerabilitySearch.SortDirection == "asc" ? query.OrderBy(v => v.Date) : query.OrderByDescending(v => v.Date);
                            break;
                        case "severity":
                            query = vulnerabilitySearch.SortDirection == "asc" ? query.OrderBy(v => v.Severity) : query.OrderByDescending(v => v.Severity);
                            break;
                        case "company":
                            query = vulnerabilitySearch.SortDirection == "asc" ? query.OrderBy(v => v.Company) : query.OrderByDescending(v => v.Company);
                            break;
                        case "source":
                            query = vulnerabilitySearch.SortDirection == "asc" ? query.OrderBy(v => v.Source) : query.OrderByDescending(v => v.Source);
                            break;
                        case "protocol":
                            query = vulnerabilitySearch.SortDirection == "asc" ? query.OrderBy(v => v.Protocol) : query.OrderByDescending(v => v.Protocol);
                            break;
                        case "title":
                            query = vulnerabilitySearch.SortDirection == "asc" ? query.OrderBy(v => v.Title) : query.OrderByDescending(v => v.Title);
                            break;
                        case "description":
                            query = vulnerabilitySearch.SortDirection == "asc" ? query.OrderBy(v => v.Description) : query.OrderByDescending(v => v.Description);
                            break;
                        default:
                            throw new ArgumentException("Invalid sort by option");
                    }
                }
                else
                {
                    query = query.OrderByDescending(v => v.Id);
                }
                var list = await query.ToListAsync();
                if (vulnerabilitySearch.Categories != null && vulnerabilitySearch.Categories.Count > 0)
                {
                    list = list.Where(v => v.Categories != null && v.Categories.Any(c => vulnerabilitySearch.Categories.Contains(c))).ToList();
                }
                return list;
            }
            else
            {
                query = query.OrderByDescending(v => v.Id);
            }

            return await query.ToListAsync();
        }

        public async Task<VulnerabilityModel> Add(VulnerabilityModel vulnerabilityModel)
        {
            if (vulnerabilityModel == null)
                throw new ArgumentNullException(nameof(vulnerabilityModel));
            vulnerabilityModel.Status = VulnerabilityModelStatus.New;
            _db.Vulnerability.Add(vulnerabilityModel);
            await _db.SaveChangesAsync();
            return vulnerabilityModel;
        }

        public async Task<VulnerabilityModel> Edit(VulnerabilityModel vulnerabilityModel, string userName)
        {
            if (vulnerabilityModel.Id == 0) throw new ArgumentException("Identifier mustn't be zero");
            var existing = await _db.Vulnerability.FirstAsync(item => item.Id == vulnerabilityModel.Id);
            _db.Entry(existing).CurrentValues.SetValues(vulnerabilityModel);
            existing.LastActionBy = userName;
            existing.LastActionAt = DateTime.UtcNow;
            _db.Vulnerability.Update(existing);
            await _db.SaveChangesAsync();
            return existing;
        }

        public async Task Approve(int vulnerabilityId, string userName)
        {
            var existing = await _db.Vulnerability.FirstAsync(item => item.Id == vulnerabilityId);
            existing.Status = VulnerabilityModelStatus.Approved;
            existing.LastActionBy = userName;
            existing.LastActionAt = DateTime.UtcNow;
            _db.Vulnerability.Update(existing);
            await _db.SaveChangesAsync();
        }

        public async Task Reject(int vulnerabilityId, string userName)
        {
            var existing = await _db.Vulnerability.FirstAsync(item => item.Id == vulnerabilityId);
            existing.Status = VulnerabilityModelStatus.Rejected;
            existing.LastActionBy = userName;
            existing.LastActionAt = DateTime.UtcNow;
            _db.Vulnerability.Update(existing);
            await _db.SaveChangesAsync();
        }

        public async Task Remove(int vulnerabilityId)
        {
            var existing = await _db.Vulnerability.FirstAsync(item => item.Id == vulnerabilityId);
            if (existing == null)
                return;
            _db.Vulnerability.Remove(existing);
            await _db.SaveChangesAsync();
        }

        public async Task<VulnerabilityModel> Get(int vulnerabilityId)
        {
            return await _db.Vulnerability
                .AsNoTracking()
                .FirstOrDefaultAsync(v => v.Id == vulnerabilityId);
        }

        public async Task<VulnerabilityModel> Update(string userName, VulnerabilityModel vulnerabilityModel)
        {
            if (vulnerabilityModel == null)
                throw new ArgumentNullException(nameof(vulnerabilityModel));
            var existing = await _db.Vulnerability.FirstAsync(item => item.Id == vulnerabilityModel.Id);
            _db.Entry(existing).CurrentValues.SetValues(vulnerabilityModel);
            existing.LastActionBy = userName;
            existing.LastActionAt = DateTime.UtcNow;
            _db.Vulnerability.Update(existing);
            await _db.SaveChangesAsync();
            return existing;
        }

        public async Task<List<VulnerabilityModel>> GetList()
        {
            return await _db.Vulnerability
                .AsNoTracking()
                .OrderByDescending(v => v.Id)
                .ToListAsync();
        }
    }

    public interface IVulnerabilityProcessor
    {
        Task<List<VulnerabilityModel>> Search(VulnerabilitySearchModel vulnerabilitySearch);
        Task<VulnerabilityModel> Add(VulnerabilityModel vulnerabilityModel);
        Task<VulnerabilityModel> Edit(VulnerabilityModel vulnerabilityModel, string userName);
        Task Approve(int vulnerabilityId, string userName);
        Task Reject(int vulnerabilityId, string userName);
        Task Remove(int vulnerabilityId);
        Task<VulnerabilityModel> Get(int vulnerabilityId);
        Task<VulnerabilityModel> Update(string userName, VulnerabilityModel vulnerabilityModel);
        Task<List<VulnerabilityModel>> GetList();
    }
}