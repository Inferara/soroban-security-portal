using SorobanSecurityPortalApi.Common.Data;
using SorobanSecurityPortalApi.Models.DbModels;
using Microsoft.EntityFrameworkCore;
using Pgvector;
using static SorobanSecurityPortalApi.Common.ExceptionHandlingMiddleware;
using SorobanSecurityPortalApi.Common.Extensions;
using SorobanSecurityPortalApi.Common;
using SorobanSecurityPortalApi.Models.ViewModels;
using System.Text.Json;
using Pgvector.EntityFrameworkCore;

namespace SorobanSecurityPortalApi.Data.Processors
{
    public class VulnerabilityProcessor : IVulnerabilityProcessor
    {
        private readonly IDbContextFactory<Db> _dbFactory;
        private readonly ExtendedConfig _extendedConfig;

        public VulnerabilityProcessor(IDbContextFactory<Db> dbFactory, ExtendedConfig extendedConfig)
        {
            _dbFactory = dbFactory;
            _extendedConfig = extendedConfig;
        }

        public async Task<List<VulnerabilityModel>> Search(VulnerabilitySearchModel? s)
        {
            await using var db = await _dbFactory.CreateDbContextAsync();
            var query = BuildFilteredQuery(s, db);
            if (s == null || string.IsNullOrWhiteSpace(s.SearchText))
            {
                query = ApplySorting(query, s?.SortBy, s?.SortDirection) ?? query.OrderByDescending(v => v.Id);
            }
            if (s?.PageSize < 0)
                return await query.ToListAsync();
            var page = s?.Page is > 0 ? s.Page!.Value : 1;
            var pageSize = s?.PageSize is > 0 ? s.PageSize!.Value : 20;

            return await query
                .Skip((page - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();
        }

        public async Task<int> SearchTotal(VulnerabilitySearchModel? s)
        {
            await using var db = await _dbFactory.CreateDbContextAsync();
            var query = BuildFilteredQuery(s, db);
            return await query.CountAsync();
        }

        private IQueryable<VulnerabilityModel> BuildFilteredQuery(VulnerabilitySearchModel? s, Db db)
        {
            var query = db.Vulnerability
                .AsNoTracking()
                .Include(v => v.Report)
                    .ThenInclude(r => r.Protocol)
                    .ThenInclude(p => p.Company)
                .Include(v => v.Report)
                    .ThenInclude(r => r.Auditor)
                .Where(v => v.Status == VulnerabilityModelStatus.Approved && v.Category != VulnerabilityCategory.Invalid);

            if (s == null) return query;

            if (s.From is not null)
            {
                var fromUtc = s.From.Value.Kind == DateTimeKind.Utc ? s.From.Value : s.From.Value.ToUniversalTime();
                query = query.Where(v => v.Date >= fromUtc);
            }

            if (s.To is not null)
            {
                var toUtc = s.To.Value.Kind == DateTimeKind.Utc ? s.To.Value : s.To.Value.ToUniversalTime();
                query = query.Where(v => v.Date <= toUtc);
            }

            // Build a single scoring expression
            if (!string.IsNullOrWhiteSpace(s.SearchText) || s.Embedding is not null)
            {
                var searchText = s.SearchText ?? "";
                var queryEmbedding = s.Embedding;

                query = query
                    .Select(v => new
                    {
                        v,
                        TextScore =
                        (string.IsNullOrEmpty(searchText)
                        ? 0.0
                                : (TrigramExtensions.TrigramSimilarity(v.Title, searchText) * _extendedConfig.TrigramNameWeight
                                   + TrigramExtensions.TrigramSimilarity(v.Description, searchText) * _extendedConfig.TrigramContentWeight)),
                        VecScore =
                            (queryEmbedding == null || v.Embedding == null)
                        ? 0.0
                                : (1.0 - v.Embedding.CosineDistance(queryEmbedding!)) * _extendedConfig.VectorContentWeight
                    })
                    .Where(x => _extendedConfig.MinRelevanceForSearch < (x.TextScore + x.VecScore))
                    .OrderByDescending(x => x.TextScore + x.VecScore)
                    .Select(x => x.v);
            }
            else
            {
                query = query.OrderByDescending(v => v.Id);
            }

            if (s.CompanyNames is { Count: > 0 })
                query = query.Where(v => s.CompanyNames.Contains(v.Report.Protocol.Company.Name));

            if (s.ReportNames is { Count: > 0 })
                query = query.Where(v => s.ReportNames.Contains(v.Report.Name));

            if (s.AuditorNames is { Count: > 0 })
                query = query.Where(v => s.AuditorNames.Contains(v.Report.Auditor.Name));

            if (s.ProtocolNames is { Count: > 0 })
                query = query.Where(v => s.ProtocolNames.Contains(v.Report.Protocol.Name));

            if (s.Severities is { Count: > 0 })
                query = query.Where(v => s.Severities.Contains(v.Severity));

            if (s.Categories is { Count: > 0 })
                query = query.Where(v => s.Categories.Contains(v.Category));
            else
                query = query.Where(v => v.Category != VulnerabilityCategory.NA);

            if (s.Tags is { Count: > 0 })
            {
                var tagsArray = s.Tags.ToArray();
                var serializedTags = JsonSerializer.Serialize(tagsArray);
                query = query.Where(v => v.Tags != null && EF.Functions.JsonContains(v.Tags, serializedTags));
            }

            if (s.ReportIds is { Count: > 0 })
                query = query.Where(v => s.ReportIds.Contains(v.Report.Id));
            if (s.ProtocolIds is { Count: > 0 })
                query = query.Where(v => s.ProtocolIds.Contains(v.Report.Protocol.Id));
            if (s.AuditorIds is { Count: > 0 })
                query = query.Where(v => s.AuditorIds.Contains(v.Report.Auditor.Id));
            if (s.CompanyIds is { Count: > 0 })
                query = query.Where(v => s.CompanyIds.Contains(v.Report.Protocol.Company.Id));

            return query;
        }

        private static IOrderedQueryable<VulnerabilityModel>? ApplySorting(
            IQueryable<VulnerabilityModel> query,
            string? sortBy,
            string? sortDirection)
        {
            if (string.IsNullOrWhiteSpace(sortBy)) return null;

            var asc = string.Equals(sortDirection, "asc", StringComparison.OrdinalIgnoreCase);

            return sortBy.ToLowerInvariant() switch
            {
                "date" => asc ? query.OrderBy(v => v.Date) : query.OrderByDescending(v => v.Date),
                "severity" => asc ? query.OrderBy(v => v.Severity) : query.OrderByDescending(v => v.Severity),
                "company" => asc ? query.OrderBy(v => v.Report.Protocol.Company.Name) : query.OrderByDescending(v => v.Report.Protocol.Company.Name),
                "source" => asc ? query.OrderBy(v => v.Report.Name) : query.OrderByDescending(v => v.Report.Name),
                "protocol" => asc ? query.OrderBy(v => v.Report.Protocol.Name) : query.OrderByDescending(v => v.Report.Protocol.Name),
                "title" => asc ? query.OrderBy(v => v.Title) : query.OrderByDescending(v => v.Title),
                "description" => asc ? query.OrderBy(v => v.Description) : query.OrderByDescending(v => v.Description),
                _ => null
            };
        }


        public async Task<VulnerabilityModel> Add(VulnerabilityModel vulnerabilityModel)
        {
            await using var db = await _dbFactory.CreateDbContextAsync();
            if (vulnerabilityModel == null)
                throw new ArgumentNullException(nameof(vulnerabilityModel));
            vulnerabilityModel.Status = VulnerabilityModelStatus.New;
            db.Vulnerability.Add(vulnerabilityModel);
            await db.SaveChangesAsync();
            return vulnerabilityModel;
        }

        public async Task<VulnerabilityModel> Edit(VulnerabilityModel vulnerabilityModel, int userId)
        {
            await using var db = await _dbFactory.CreateDbContextAsync();
            if (vulnerabilityModel.Id == 0) throw new ArgumentException("Identifier mustn't be zero");
            var existing = await db.Vulnerability.FirstAsync(item => item.Id == vulnerabilityModel.Id);
            db.Entry(existing).CurrentValues.SetValues(vulnerabilityModel);
            existing.LastActionBy = userId;
            existing.LastActionAt = DateTime.UtcNow;
            db.Vulnerability.Update(existing);
            await db.SaveChangesAsync();
            return existing;
        }

        public async Task Approve(VulnerabilityModel vulnerabilityModel, int userId)
        {
            await using var db = await _dbFactory.CreateDbContextAsync();
            vulnerabilityModel.Status = VulnerabilityModelStatus.Approved;
            vulnerabilityModel.LastActionBy = userId;
            vulnerabilityModel.LastActionAt = DateTime.UtcNow;
            db.Vulnerability.Update(vulnerabilityModel);
            await db.SaveChangesAsync();
        }

        public async Task Reject(VulnerabilityModel vulnerabilityModel, int loginId)
        {
            await using var db = await _dbFactory.CreateDbContextAsync();
            vulnerabilityModel.Status = VulnerabilityModelStatus.Rejected;
            vulnerabilityModel.LastActionBy = loginId;
            vulnerabilityModel.LastActionAt = DateTime.UtcNow;
            db.Vulnerability.Update(vulnerabilityModel);
            await db.SaveChangesAsync();
        }

        public async Task Remove(int vulnerabilityId)
        {
            await using var db = await _dbFactory.CreateDbContextAsync();
            var existing = await db.Vulnerability.FirstAsync(item => item.Id == vulnerabilityId);
            if (existing == null)
                return;
            db.Vulnerability.Remove(existing);
            await db.SaveChangesAsync();
        }

        public async Task<VulnerabilityModel?> Get(int vulnerabilityId)
        {
            await using var db = await _dbFactory.CreateDbContextAsync();
            return await db.Vulnerability
                .Include(v => v.Report)
                    .ThenInclude(r => r.Protocol)
                    .ThenInclude(p => p.Company)
                .Include(v => v.Report)
                    .ThenInclude(r => r.Auditor)
                .AsNoTracking()
                .FirstOrDefaultAsync(v => v.Id == vulnerabilityId);
        }

        public async Task<VulnerabilityModel> Update(int userId, VulnerabilityModel vulnerabilityModel)
        {
            await using var db = await _dbFactory.CreateDbContextAsync();
            if (vulnerabilityModel == null)
                throw new ArgumentNullException(nameof(vulnerabilityModel));
            var existing = await db.Vulnerability.FirstAsync(item => item.Id == vulnerabilityModel.Id);
            db.Entry(existing).CurrentValues.SetValues(vulnerabilityModel);
            existing.LastActionBy = userId;
            existing.LastActionAt = DateTime.UtcNow;
            db.Vulnerability.Update(existing);
            await db.SaveChangesAsync();
            return existing;
        }

        public async Task<List<VulnerabilityModel>> GetList()
        {
            await using var db = await _dbFactory.CreateDbContextAsync();
            return await db.Vulnerability
                .Include(v => v.Report)
                    .ThenInclude(r => r.Protocol)
                    .ThenInclude(p => p.Company)
                .Include(v => v.Report)
                    .ThenInclude(r => r.Auditor)
                .AsNoTracking()
                .OrderByDescending(v => v.Id)
                .ToListAsync();
        }

        public async Task<List<VulnerabilityModel>> GetListForEmbedding()
        {
            await using var db = await _dbFactory.CreateDbContextAsync();
            return await db.Vulnerability
                .AsNoTracking()
                .Where(v => v.Embedding == null)
                .OrderByDescending(v => v.Id)
                .ToListAsync();
        }

        public async Task UpdateEmbedding(int vulnerabilityId, Vector embedding)
        {
            await using var db = await _dbFactory.CreateDbContextAsync();
            var existing = await db.Vulnerability.FirstAsync(item => item.Id == vulnerabilityId);
            if (existing == null)
                throw new SorobanSecurityPortalUiException($"Vulnerability with ID {vulnerabilityId} not found.");
            existing.Embedding = embedding;
            db.Vulnerability.Update(existing);
            await db.SaveChangesAsync();
        }

        public async Task<VulnerabilitiesStatisticsViewModel> GetStatistics()
        {
            await using var db = await _dbFactory.CreateDbContextAsync();
            var bySeverity = await db.Vulnerability
                    .AsNoTracking()
                    .Where(v => v.Status == VulnerabilityModelStatus.Approved && v.Category != VulnerabilityCategory.Invalid)
                    .GroupBy(v => v.Severity)
                    .Select(g => new
                    {
                        Severity = g.Key.ToLowerInvariant(),
                        Count = g.Count()
                    })
                    .ToListAsync();

            var vulnerabilitiesWithTags = await db.Vulnerability
                .AsNoTracking()
                .Where(v => v.Status == VulnerabilityModelStatus.Approved && v.Category != VulnerabilityCategory.Invalid && v.Tags != null)
                .ToListAsync();

            var byTag = vulnerabilitiesWithTags
                .SelectMany(v => v.Tags.Select(c => new { v.Id, Category = c }))
                .GroupBy(x => x.Category.ToLowerInvariant())
                .Select(g => new
                {
                    Tag = g.Key.ToLowerInvariant(),
                    Count = g.Count()
                })
                .ToList();

            var byCategory = await db.Vulnerability
                    .AsNoTracking()
                    .Where(v => v.Status == VulnerabilityModelStatus.Approved && v.Category != VulnerabilityCategory.Invalid)
                    .GroupBy(v => v.Category)
                    .Select(g => new
                    {
                        Category = g.Key.ToString(),
                        Count = g.Count()
                    })
                    .ToListAsync();
            return new VulnerabilitiesStatisticsViewModel
            {
                Total = await db.Vulnerability
                    .AsNoTracking()
                    .CountAsync(v => v.Status == VulnerabilityModelStatus.Approved && v.Category != VulnerabilityCategory.Invalid),
                BySeverity = bySeverity.ToDictionary(x => x.Severity, x => x.Count),
                ByTag = byTag.ToDictionary(x => x.Tag, x => x.Count),
                ByCategory = byCategory.ToDictionary(x => x.Category, x => x.Count)
            };
        }

        public async Task<VulnerabilityStatisticsChangesViewModel> GetStatisticsChanges()
        {
            await using var db = await _dbFactory.CreateDbContextAsync();
            var ago = DateTime.UtcNow.AddMonths(-1);
            var newVulnerabilities = await db.Vulnerability
                .AsNoTracking()
                .Where(v => v.Status == VulnerabilityModelStatus.Approved && v.Category != VulnerabilityCategory.Invalid && v.Date >= ago)
                .CountAsync();
            return new VulnerabilityStatisticsChangesViewModel
            {
                Total = db.Vulnerability
                    .AsNoTracking()
                    .Count(v => v.Status == VulnerabilityModelStatus.Approved && v.Category != VulnerabilityCategory.Invalid),
                New = newVulnerabilities
            };
        }
    }

    public interface IVulnerabilityProcessor
    {
        Task<List<VulnerabilityModel>> Search(VulnerabilitySearchModel vulnerabilitySearch);
        Task<int> SearchTotal(VulnerabilitySearchModel vulnerabilitySearch);
        Task<VulnerabilityModel> Add(VulnerabilityModel vulnerabilityModel);
        Task<VulnerabilityModel> Edit(VulnerabilityModel vulnerabilityModel, int userId);
        Task Approve(VulnerabilityModel vulnerabilityModel, int userId);
        Task Reject(VulnerabilityModel vulnerabilityModel, int userId);
        Task Remove(int vulnerabilityId);
        Task<VulnerabilityModel?> Get(int vulnerabilityId);
        Task<VulnerabilityModel> Update(int userId, VulnerabilityModel vulnerabilityModel);
        Task<List<VulnerabilityModel>> GetList();
        Task<List<VulnerabilityModel>> GetListForEmbedding();
        Task UpdateEmbedding(int vulnerabilityId, Vector embedding);
        Task<VulnerabilitiesStatisticsViewModel> GetStatistics();
        Task<VulnerabilityStatisticsChangesViewModel> GetStatisticsChanges();
    }
}