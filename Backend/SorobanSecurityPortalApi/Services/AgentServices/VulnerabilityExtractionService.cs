using System.Diagnostics;
using System.Text;
using System.Text.Json;
using Pgvector;
using SorobanSecurityPortalApi.Common;
using SorobanSecurityPortalApi.Data.Processors;
using SorobanSecurityPortalApi.Models.DbModels;
using SorobanSecurityPortalApi.Models.ViewModels;
using SorobanSecurityPortalApi.Services.AgentServices.Types;

namespace SorobanSecurityPortalApi.Services.AgentServices;

/// <summary>
/// Service that orchestrates the multi-agent pipeline for extracting vulnerabilities from audit reports.
/// </summary>
public class VulnerabilityExtractionService : IVulnerabilityExtractionService
{
    private readonly IGeminiAgentService _agentService;
    private readonly IReportProcessor _reportProcessor;
    private readonly IVulnerabilityProcessor _vulnerabilityProcessor;
    private readonly ICategoryProcessor _categoryProcessor;
    private readonly IGeminiEmbeddingService _embeddingService;
    private readonly UserContextAccessor _userContextAccessor;
    private readonly ILogger<VulnerabilityExtractionService> _logger;

    public VulnerabilityExtractionService(
        IGeminiAgentService agentService,
        IReportProcessor reportProcessor,
        IVulnerabilityProcessor vulnerabilityProcessor,
        ICategoryProcessor categoryProcessor,
        IGeminiEmbeddingService embeddingService,
        UserContextAccessor userContextAccessor,
        ILogger<VulnerabilityExtractionService> logger)
    {
        _agentService = agentService;
        _reportProcessor = reportProcessor;
        _vulnerabilityProcessor = vulnerabilityProcessor;
        _categoryProcessor = categoryProcessor;
        _embeddingService = embeddingService;
        _userContextAccessor = userContextAccessor;
        _logger = logger;
    }

    public async Task<Result<VulnerabilityExtractionResultViewModel, string>> ExtractVulnerabilitiesAsync(
        int reportId,
        VulnerabilityExtractionOptions? options = null,
        CancellationToken ct = default)
    {
        var stopwatch = Stopwatch.StartNew();
        options ??= new VulnerabilityExtractionOptions();
        var result = new VulnerabilityExtractionResultViewModel();

        try
        {
            var report = await _reportProcessor.Get(reportId);
            if (report == null)
            {
                return new Result<VulnerabilityExtractionResultViewModel, string>.Err(
                    $"Report with ID {reportId} not found.");
            }

            if (string.IsNullOrWhiteSpace(report.MdFile))
            {
                return new Result<VulnerabilityExtractionResultViewModel, string>.Err(
                    "Report does not have markdown content for extraction.");
            }

            // Check markdown size to prevent memory issues (limit to 5MB)
            const int MaxMarkdownSizeBytes = 5 * 1024 * 1024;
            if (report.MdFile.Length > MaxMarkdownSizeBytes)
            {
                return new Result<VulnerabilityExtractionResultViewModel, string>.Err(
                    $"Report markdown content is too large ({report.MdFile.Length / 1024 / 1024}MB). Maximum supported size is 5MB.");
            }

            _logger.LogInformation(
                "Starting vulnerability extraction for report {ReportId}: {ReportName}",
                reportId,
                report.Name);

            var existingVulnerabilities = await GetExistingVulnerabilitiesForReport(reportId);
            var examples = await GetDiverseExampleVulnerabilities(10);
            var availableTags = await _categoryProcessor.List();
            var tagNames = availableTags.Select(t => t.Name).ToList();
            var validatedVulnerabilities = await RunAgentPipelineAsync(
                report.MdFile,
                examples,
                tagNames,
                result,
                ct);

            if (validatedVulnerabilities == null || validatedVulnerabilities.Count == 0)
            {
                result.ProcessingTimeMs = stopwatch.ElapsedMilliseconds;
                return new Result<VulnerabilityExtractionResultViewModel, string>.Ok(result);
            }

            result.TotalExtracted = validatedVulnerabilities.Count;
            var userId = await _userContextAccessor.GetLoginIdAsync();
            var createdVulnerabilities = await CreateVulnerabilitiesAsync(
                validatedVulnerabilities,
                existingVulnerabilities,
                reportId,
                userId,
                ct);

            result.TotalCreated = createdVulnerabilities.Count;
            result.DuplicatesSkipped = result.TotalExtracted - result.TotalCreated;
            result.CreatedVulnerabilityIds = createdVulnerabilities.Select(v => v.Id).ToList();
            result.ProcessingTimeMs = stopwatch.ElapsedMilliseconds;

            _logger.LogInformation(
                "Vulnerability extraction completed for report {ReportId}: {Extracted} extracted, {Created} created, {Skipped} skipped in {TimeMs}ms",
                reportId,
                result.TotalExtracted,
                result.TotalCreated,
                result.DuplicatesSkipped,
                result.ProcessingTimeMs);

            return new Result<VulnerabilityExtractionResultViewModel, string>.Ok(result);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during vulnerability extraction for report {ReportId}", reportId);
            result.ProcessingErrors.Add($"Extraction failed: {ex.Message}");
            result.ProcessingTimeMs = stopwatch.ElapsedMilliseconds;
            return new Result<VulnerabilityExtractionResultViewModel, string>.Err(ex.Message);
        }
    }

    private async Task<List<VulnerabilityModel>> GetExistingVulnerabilitiesForReport(int reportId)
    {
        var searchModel = new VulnerabilitySearchModel
        {
            ReportIds = new List<int> { reportId },
            PageSize = -1 // Get all
        };
        return await _vulnerabilityProcessor.Search(searchModel);
    }

    private async Task<List<VulnerabilityModel>> GetDiverseExampleVulnerabilities(int count)
    {
        // Get approved vulnerabilities with good distribution across severities
        var allVulnerabilities = await _vulnerabilityProcessor.GetList();
        var approved = allVulnerabilities
            .Where(v => v.Status == VulnerabilityModelStatus.Approved)
            .ToList();

        if (approved.Count == 0)
            return new List<VulnerabilityModel>();

        // Try to get diverse examples across severities
        var examples = new List<VulnerabilityModel>();
        var severities = new[] { "critical", "high", "medium", "low", "note" };
        var perSeverity = Math.Max(1, count / severities.Length);

        foreach (var severity in severities)
        {
            var bySeverity = approved
                .Where(v => v.Severity?.ToLowerInvariant() == severity)
                .Take(perSeverity)
                .ToList();
            examples.AddRange(bySeverity);
        }

        // Fill remaining slots with random approved vulnerabilities
        if (examples.Count < count)
        {
            var remaining = approved
                .Except(examples)
                .Take(count - examples.Count);
            examples.AddRange(remaining);
        }

        return examples.Take(count).ToList();
    }

    private async Task<List<ClassifiedVulnerability>?> RunAgentPipelineAsync(
        string markdownContent,
        List<VulnerabilityModel> examples,
        List<string> availableTags,
        VulnerabilityExtractionResultViewModel result,
        CancellationToken ct)
    {
        _logger.LogInformation("Running Parser Agent...");
        var parserPrompt = $"Analyze the following audit report and identify all vulnerability sections:\n\n{markdownContent}";
        var parserResult = await _agentService.CallAgentAsync(AgentType.Parser, parserPrompt, ct);

        if (parserResult is Result<string, string>.Err parserErr)
        {
            result.ProcessingErrors.Add($"Parser Agent failed: {parserErr.Error}");
            return null;
        }

        var parserResponse = ParseJsonResponse<ParserAgentResponse>(
            ((Result<string, string>.Ok)parserResult).Value);

        if (parserResponse?.Sections == null || parserResponse.Sections.Count == 0)
        {
            result.ValidationWarnings.Add("No vulnerability sections found in the report.");
            return new ();
        }

        _logger.LogInformation("Parser Agent found {Count} sections", parserResponse.Sections.Count);

        _logger.LogInformation("Running Extractor Agent...");
        var extractorPrompt = BuildExtractorPrompt(parserResponse.Sections, markdownContent);
        var extractorResult = await _agentService.CallAgentAsync(AgentType.Extractor, extractorPrompt, ct);

        if (extractorResult is Result<string, string>.Err extractorErr)
        {
            result.ProcessingErrors.Add($"Extractor Agent failed: {extractorErr.Error}");
            return null;
        }

        var extractorResponse = ParseJsonResponse<ExtractorAgentResponse>(
            ((Result<string, string>.Ok)extractorResult).Value);

        if (extractorResponse?.Vulnerabilities == null || extractorResponse.Vulnerabilities.Count == 0)
        {
            result.ValidationWarnings.Add("No vulnerabilities extracted from sections.");
            return new ();
        }

        _logger.LogInformation("Extractor Agent extracted {Count} vulnerabilities", extractorResponse.Vulnerabilities.Count);

        List<ClassifiedVulnerability> classifiedVulnerabilities = new();
        try
        {
            _logger.LogInformation("Running Classifier Agent...");
            var classifierPrompt = BuildClassifierPrompt(extractorResponse.Vulnerabilities, examples, availableTags);
            var classifierResult = await _agentService.CallAgentAsync(AgentType.Classifier, classifierPrompt, ct);

            if (classifierResult is Result<string, string>.Ok classifierOk)
            {
                var classifierResponse = ParseJsonResponse<ClassifierAgentResponse>(classifierOk.Value);
                if (classifierResponse?.Vulnerabilities != null && classifierResponse.Vulnerabilities.Count > 0)
                {
                    classifiedVulnerabilities = classifierResponse.Vulnerabilities;
                    _logger.LogInformation("Classifier Agent classified {Count} vulnerabilities", classifiedVulnerabilities.Count);
                }
            }
            else if (classifierResult is Result<string, string>.Err classifierErr)
            {
                result.ValidationWarnings.Add($"Classification skipped: {classifierErr.Error}");
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Classifier Agent failed, using default classifications");
            result.ValidationWarnings.Add("Classification failed, using default values");
        }

        // If classification failed, convert extracted vulnerabilities to classified with defaults
        if (classifiedVulnerabilities == null || classifiedVulnerabilities.Count == 0)
        {
            _logger.LogInformation("Using extracted vulnerabilities with default classifications");
            classifiedVulnerabilities = extractorResponse.Vulnerabilities
                .Select(raw => new ClassifiedVulnerability
                {
                    SectionId = raw.SectionId,
                    Title = raw.Title,
                    Description = raw.Description,
                    Impact = raw.Impact,
                    Recommendation = raw.Recommendation,
                    Location = raw.Location,
                    CodeBlocks = raw.CodeBlocks,
                    Links = raw.Links,
                    Severity = "medium", // Default severity
                    Tags = new List<string>(),
                    Category = 100 // N/A
                })
                .ToList();
        }

        _logger.LogInformation("Pipeline complete: {Count} vulnerabilities ready for creation", classifiedVulnerabilities.Count);
        return classifiedVulnerabilities;
    }

    private string BuildExtractorPrompt(List<VulnerabilitySection> sections, string markdownContent)
    {
        var sb = new StringBuilder();
        sb.AppendLine("EXTRACT ALL VULNERABILITIES from the following audit report.");
        sb.AppendLine();
        sb.AppendLine("The parser identified these sections as potential vulnerabilities:");
        foreach (var section in sections)
        {
            sb.AppendLine($"- \"{section.Title}\"");
        }
        sb.AppendLine();
        sb.AppendLine("YOUR TASK: Extract EVERY vulnerability from the report below. For each vulnerability, capture:");
        sb.AppendLine("- The exact title as it appears in the report");
        sb.AppendLine("- The COMPLETE description including ALL code blocks and technical details");
        sb.AppendLine("- The impact/consequences");
        sb.AppendLine("- The recommendation/fix (if provided)");
        sb.AppendLine("- File/function locations mentioned");
        sb.AppendLine();
        sb.AppendLine("IMPORTANT: Do NOT skip any vulnerabilities. Extract them ALL with FULL content.");
        sb.AppendLine();
        sb.AppendLine("AUDIT REPORT CONTENT:");
        sb.AppendLine(markdownContent);

        return sb.ToString();
    }

    private string BuildClassifierPrompt(
        List<RawVulnerability> vulnerabilities,
        List<VulnerabilityModel> examples,
        List<string> availableTags)
    {
        var sb = new StringBuilder();
        sb.AppendLine("Classify the following vulnerabilities based on the examples and available tags.");
        sb.AppendLine();
        sb.AppendLine("AVAILABLE TAGS (use ONLY these):");
        sb.AppendLine(string.Join(", ", availableTags));
        sb.AppendLine();
        sb.AppendLine("EXAMPLE VULNERABILITIES FROM DATABASE (use these as formatting and classification reference):");
        foreach (var example in examples.Take(5)) // Show fewer but more complete examples
        {
            sb.AppendLine($"---");
            sb.AppendLine($"Title: {example.Title}");
            sb.AppendLine($"Severity: {example.Severity}");
            sb.AppendLine($"Tags: {string.Join(", ", example.Tags ?? new List<string>())}");
            sb.AppendLine($"Category: {(int)example.Category}");
            sb.AppendLine($"Description (FULL - use this as formatting reference):");
            sb.AppendLine(TruncateText(example.Description, 2000)); // Much larger to show formatting patterns
        }
        sb.AppendLine();
        sb.AppendLine("IMPORTANT: Format the descriptions like the examples above - include markdown code blocks, links, and proper structure.");
        sb.AppendLine();
        sb.AppendLine("VULNERABILITIES TO CLASSIFY:");
        sb.AppendLine(JsonSerializer.Serialize(vulnerabilities, new JsonSerializerOptions { WriteIndented = true }));

        return sb.ToString();
    }

    private async Task<List<VulnerabilityModel>> CreateVulnerabilitiesAsync(
        List<ClassifiedVulnerability> classifiedVulnerabilities,
        List<VulnerabilityModel> existingVulnerabilities,
        int reportId,
        int userId,
        CancellationToken ct)
    {
        var createdVulnerabilities = new List<VulnerabilityModel>();
        var existingTitles = existingVulnerabilities
            .Select(v => v.Title?.ToLowerInvariant() ?? "")
            .ToHashSet();

        foreach (var classified in classifiedVulnerabilities)
        {
            ct.ThrowIfCancellationRequested();
            var normalizedTitle = classified.Title?.ToLowerInvariant() ?? "";
            if (existingTitles.Contains(normalizedTitle))
            {
                _logger.LogDebug("Skipping duplicate vulnerability: {Title}", classified.Title);
                continue;
            }

            var vulnModel = new VulnerabilityModel
            {
                Title = classified.Title!,
                Description = classified.Description,
                Severity = NormalizeSeverity(classified.Severity),
                Tags = classified.Tags?.Count > 0 ? classified.Tags : null,
                Category = (VulnerabilityCategory)classified.Category,
                ReportId = reportId,
                ReportUrl = "",
                Date = DateTime.UtcNow,
                Status = VulnerabilityModelStatus.New,
                CreatedBy = userId,
                LastActionBy = userId,
                LastActionAt = DateTime.UtcNow,
                PicturesContainerGuid = Guid.NewGuid().ToString()
            };

            try
            {
                var embeddingText = $"{classified.Title}\n{classified.Description}";
                var embedding = await _embeddingService.GenerateEmbeddingForDocumentAsync(embeddingText);
                vulnModel.Embedding = new Vector(embedding);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to generate embedding for vulnerability: {Title}", classified.Title);
            }

            var created = await _vulnerabilityProcessor.Add(vulnModel);
            createdVulnerabilities.Add(created);
            existingTitles.Add(normalizedTitle);

            _logger.LogDebug("Created vulnerability: {Title} (ID: {Id})", created.Title, created.Id);
        }

        return createdVulnerabilities;
    }

    private static string NormalizeSeverity(string? severity)
    {
        return severity?.ToLowerInvariant() switch
        {
            "critical" => VulnerabilitySeverity.Critical,
            "high" => VulnerabilitySeverity.High,
            "medium" => VulnerabilitySeverity.Medium,
            "low" => VulnerabilitySeverity.Low,
            "note" or "info" or "informational" => VulnerabilitySeverity.Note,
            _ => VulnerabilitySeverity.Medium
        };
    }

    private static string TruncateText(string? text, int maxLength)
    {
        if (string.IsNullOrWhiteSpace(text))
            return "";
        if (text.Length <= maxLength)
            return text;
        return text[..maxLength] + "...";
    }

    private T? ParseJsonResponse<T>(string json) where T : class
    {
        if (string.IsNullOrWhiteSpace(json))
            return null;

        var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        var cleanedJson = PreprocessLlmJson(json);
        try
        {
            return JsonSerializer.Deserialize<T>(cleanedJson, options);
        }
        catch (JsonException ex)
        {
            _logger.LogWarning(
                "Initial JSON parse failed for {TypeName} at position {Position}: {Message}",
                typeof(T).Name,
                ex.BytePositionInLine,
                ex.Message);

            LogJsonErrorContext(cleanedJson, ex.BytePositionInLine ?? 0);
        }

        var repairedJson = TryRepairTruncatedJson(cleanedJson);
        if (repairedJson != null && repairedJson != cleanedJson)
        {
            try
            {
                var result = JsonSerializer.Deserialize<T>(repairedJson, options);
                if (result != null)
                {
                    _logger.LogInformation("Successfully parsed JSON after repair for {TypeName}", typeof(T).Name);
                    return result;
                }
            }
            catch (JsonException ex)
            {
                _logger.LogWarning(
                    ex,
                    "Failed to parse repaired JSON for {TypeName}. Response length: {Length}",
                    typeof(T).Name,
                    json.Length);
            }
        }

        _logger.LogError(
            "Could not parse or repair JSON response for {TypeName}. Response length: {Length}. First 500 chars: {Sample}",
            typeof(T).Name,
            json.Length,
            json.Length > 500 ? json[..500] : json);
        return null;
    }

    /// <summary>
    /// Pre-processes LLM JSON output to fix common issues.
    /// </summary>
    private static string PreprocessLlmJson(string json)
    {
        if (string.IsNullOrWhiteSpace(json))
            return json;

        var result = json.Trim();

        // Remove markdown code block wrappers if present
        if (result.StartsWith("```json", StringComparison.OrdinalIgnoreCase))
        {
            result = result[7..];
        }
        else if (result.StartsWith("```"))
        {
            result = result[3..];
        }

        if (result.EndsWith("```"))
        {
            result = result[..^3];
        }

        result = result.Trim();

        return result;
    }

    /// <summary>
    /// Logs context around a JSON parsing error position for debugging.
    /// </summary>
    private void LogJsonErrorContext(string json, long position)
    {
        if (string.IsNullOrEmpty(json) || position < 0)
            return;

        var pos = (int)Math.Min(position, json.Length - 1);
        var start = Math.Max(0, pos - 100);
        var end = Math.Min(json.Length, pos + 100);
        var context = json[start..end];

        // Escape control characters for logging
        context = context
            .Replace("\r", "\\r")
            .Replace("\n", "\\n")
            .Replace("\t", "\\t");

        _logger.LogWarning(
            "JSON error context (position {Position}): ...{Context}...",
            position,
            context);
    }

    /// <summary>
    /// Attempts to repair truncated JSON by closing open strings, arrays, and objects.
    /// </summary>
    private static string? TryRepairTruncatedJson(string json)
    {
        if (string.IsNullOrWhiteSpace(json))
            return null;

        var sb = new StringBuilder(json);
        var openBraces = 0;
        var openBrackets = 0;
        var inString = false;
        var lastCharWasEscape = false;

        for (var i = 0; i < json.Length; i++)
        {
            var c = json[i];

            if (lastCharWasEscape)
            {
                lastCharWasEscape = false;
                continue;
            }

            if (c == '\\')
            {
                lastCharWasEscape = true;
                continue;
            }

            if (c == '"')
            {
                inString = !inString;
                continue;
            }

            if (!inString)
            {
                switch (c)
                {
                    case '{':
                        openBraces++;
                        break;
                    case '}':
                        openBraces--;
                        break;
                    case '[':
                        openBrackets++;
                        break;
                    case ']':
                        openBrackets--;
                        break;
                }
            }
        }

        // If we're in a string that was truncated, close it
        if (inString)
        {
            // Check if the last character before truncation was part of a code block or regular text
            // We need to close the string properly
            sb.Append('"');
        }

        // Close any open arrays first (they're usually inside objects)
        while (openBrackets > 0)
        {
            sb.Append(']');
            openBrackets--;
        }

        // Close any open objects
        while (openBraces > 0)
        {
            sb.Append('}');
            openBraces--;
        }

        return sb.ToString();
    }
}
